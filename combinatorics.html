
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=ascii" />
    <title>20. Combinatorics &#8212; Logic and Proof 0.1 documentation</title>
    <link rel="stylesheet" href="_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '0.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="shortcut icon" href="_static/favicon.ico"/>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="21. The Real Numbers" href="the_real_numbers.html" />
    <link rel="prev" title="19. Elementary Number Theory" href="elementary_number_theory.html" />
<!-- <link href="https://fonts.googleapis.com/css?family=Sorts+Mill+Goudy" rel="stylesheet"> -->
<!-- <link href="https://fonts.googleapis.com/css?family=Average" rel="stylesheet"> -->
<!-- <link href="https://fonts.googleapis.com/css?family=EB+Garamond" rel="stylesheet"> -->

  </head>
  <body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="combinatorics">
<span id="id1"></span><h1>20. Combinatorics<a class="headerlink" href="#combinatorics" title="Permalink to this headline">&#182;</a></h1>
<p>Combinatorics is the art of counting without counting. It is a fundamental mathematical task to determine how many things there are in a given collection, and when the collection is large, it can be tedious or infeasible to count the elements individually. Moreover, when the collection is described in terms of a changing parameter (say, a natural number, <span class="math">\(n\)</span>), we would like a formula that tells us how the number of objects depends on that parameter. In this chapter we will set up a foundation for achieving this goal, and learn some of the tricks of the
trade.</p>
<div class="section" id="finite-sets-and-cardinality">
<h2>20.1. Finite Sets and Cardinality<a class="headerlink" href="#finite-sets-and-cardinality" title="Permalink to this headline">&#182;</a></h2>
<p>It will be helpful, for every natural number <span class="math">\(n\)</span>, to have a canonical set of elements of size <span class="math">\(n\)</span>. To that end, we will choose the set</p>
<div class="math">
\[[n] = \{ m \mid m &lt; n \} = \{ 0, 1, \ldots, n-1 \}.\]</div>
<p>We used the same notation, <span class="math">\([n]\)</span>, to describe equivalence classes with respect to an equivalence relation, but hopefully our intended meaning will always be clear from the context.</p>
<p>A set <span class="math">\(A\)</span> of elements is said to be <em>finite</em> if there is a bijection from <span class="math">\([n]\)</span> to <span class="math">\(A\)</span> for some <span class="math">\(n\)</span>. In that case, we would like to say that <span class="math">\(A\)</span> <em>has</em> <span class="math">\(n\)</span> <em>elements</em>, or that the set <span class="math">\(A\)</span> <em>has cardinality</em> <span class="math">\(n\)</span>, and write <span class="math">\(|A| = n\)</span>. But to do so, we need to know that when <span class="math">\(A\)</span> is finite, there is a unique <span class="math">\(n\)</span> with the property above.</p>
<p>Suppose there are bijections from both <span class="math">\([m]\)</span> and <span class="math">\([n]\)</span> to <span class="math">\(A\)</span>. Composing the first bijection with the inverse of the second, we get a bijection from <span class="math">\([m]\)</span> to <span class="math">\([n]\)</span>. It seems intuitively clear that this implies <span class="math">\(m = n\)</span>, but our goal is to prove this from the fundamental properties of sets, functions, and the natural numbers.</p>
<p>So suppose, for the sake of contradiction, <span class="math">\(m \neq n\)</span>. Without loss of generality, we can assume <span class="math">\(m &gt; n\)</span> (why?). In particular, there is an injective function <span class="math">\(f\)</span> from <span class="math">\([m]\)</span> to <span class="math">\([n]\)</span>. Since <span class="math">\(m &gt; n\)</span>, <span class="math">\(m \geq n+1\)</span>, and so we can restrict <span class="math">\(f\)</span> to get an injective function from <span class="math">\([n+1]\)</span> to <span class="math">\([n]\)</span>. The next theorem shows that this cannot happen.</p>
<hr class="docutils" />
<p><strong>Theorem.</strong> For any natural number <span class="math">\(n\)</span>, there is no injective function from <span class="math">\([n+1]\)</span> to <span class="math">\([n]\)</span>.</p>
<p><strong>Proof.</strong> By induction on <span class="math">\(n\)</span>. The theorem is clear when <span class="math">\(n = 0\)</span>, because <span class="math">\([1] = \{ 0 \}\)</span> and <span class="math">\([0] = \emptyset\)</span>. If <span class="math">\(f\)</span> were an injective function from <span class="math">\([1]\)</span> to <span class="math">\([0]\)</span>, we would have <span class="math">\(f(0) \in \emptyset\)</span>, which is impossible.</p>
<p>So suppose the claim is true for <span class="math">\(n\)</span>, and suppose <span class="math">\(f\)</span> is an injective function from <span class="math">\([n+2]\)</span> to <span class="math">\([n+1]\)</span>. We consider two cases.</p>
<p>In the first case, suppose <span class="math">\(n\)</span> is not in the image of <span class="math">\(f\)</span>. Then <span class="math">\(f\)</span> maps <span class="math">\([n+2]\)</span> to <span class="math">\([n]\)</span>, and restricting the domain, we have an injective function from <span class="math">\([n+1]\)</span> to <span class="math">\([n]\)</span>, contradicting the inductive hypothesis.</p>
<p>In the second case, there is some <span class="math">\(m &lt; n + 2\)</span> such that <span class="math">\(f(m) = n\)</span>. The idea is to alter <span class="math">\(f\)</span> slightly to get an injective function from <span class="math">\([n+1]\)</span> to <span class="math">\([n]\)</span>, again contradicting the inductive hypothesis. If <span class="math">\(m = n + 1\)</span>, which is to say it is the last element of <span class="math">\([n+2]\)</span> that is mapped to the last element of <span class="math">\([n+1]\)</span>, we can just restrict <span class="math">\(f\)</span> to <span class="math">\([n+1]\)</span>. The fact that <span class="math">\(f\)</span> was injective implies that all the elements in <span class="math">\([n+1]\)</span> are mapped to <span class="math">\(n\)</span>.</p>
<p>Otherwise, define <span class="math">\(f' : [n+1] \to [n]\)</span> by</p>
<div class="math">
\[\begin{split}f'(i) =
  \begin{cases}
    f(i) &amp; \mbox{if $i \neq m$} \\
    f(n+1) &amp; \mbox{if $i = m$.}
  \end{cases}\end{split}\]</div>
<p>In other words, we map <span class="math">\(m\)</span> to the value that <span class="math">\(n+1\)</span> was mapped to. Since <span class="math">\(f\)</span> is injective, <span class="math">\(f(n+1) \neq f(m)\)</span>, and so <span class="math">\(f(n+1) &lt; n\)</span>, as required. It is not hard to check that <span class="math">\(f'\)</span> is injective, so we have the contradiction we were after.</p>
<hr class="docutils" />
<p>This theorem is known as the &#8220;pigeonhole principle.&#8221; It implies that if <span class="math">\(n + 1\)</span> pigeons inhabit <span class="math">\(n\)</span> holes, then at least one hole has more than one pigeon. The principle implies that for every finite set <span class="math">\(A\)</span>, there is a unique <span class="math">\(n\)</span> such that there is a bijection from <span class="math">\([n]\)</span> to <span class="math">\(A\)</span>, and we can define the cardinality of <span class="math">\(A\)</span> to be that <span class="math">\(n\)</span>.</p>
</div>
<div class="section" id="counting-principles">
<span id="id2"></span><h2>20.2. Counting Principles<a class="headerlink" href="#counting-principles" title="Permalink to this headline">&#182;</a></h2>
<p>Here is a basic counting principle.</p>
<hr class="docutils" />
<p><strong>Theorem.</strong> Let <span class="math">\(A\)</span> and <span class="math">\(B\)</span> be disjoint finite sets. Then <span class="math">\(| A \cup B | = | A | + | B |\)</span>.</p>
<p><strong>Proof.</strong> Suppose <span class="math">\(f : [m] \to A\)</span> and <span class="math">\(g : [n] \to B\)</span> are bijections. Define <span class="math">\(h : [m + n] \to A \cup B\)</span> by</p>
<div class="math">
\[\begin{split}h(i) =
  \begin{cases}
    f(i) &amp; \mbox{if $i &lt; m$} \\
    g(i - m) &amp; \mbox{if $m \leq i &lt; m + n$.}
  \end{cases}\end{split}\]</div>
<p>To see that <span class="math">\(h\)</span> is surjective, note that every <span class="math">\(k\)</span> in <span class="math">\(A \cup B\)</span> can be written as either <span class="math">\(k = f(i)\)</span> for some <span class="math">\(i \in [m]\)</span> or <span class="math">\(k = g(j)\)</span> for some <span class="math">\(j \in [n]\)</span>. In the first case, <span class="math">\(k = f(i) = h(i)\)</span>, and in the second case, <span class="math">\(k = g(j) = h(m + j)\)</span>.</p>
<p>It is not hard to show that <span class="math">\(h\)</span> is also injective. Suppose <span class="math">\(h(i) = h(j)\)</span>. If <span class="math">\(h(i)\)</span> is in <span class="math">\(A\)</span>, then it is not in the range of <span class="math">\(g\)</span>, and so we must have <span class="math">\(h(i) = f(i)\)</span> and <span class="math">\(h(j) = f(j)\)</span>. Then <span class="math">\(f(i) = f(j)\)</span>, the injectivity of <span class="math">\(f\)</span> implies that <span class="math">\(i = j\)</span>. If <span class="math">\(h(i)\)</span> is instead in <span class="math">\(B\)</span>, the argument it similar.</p>
<hr class="docutils" />
<p>The proof only spells out our basic intuitions: if you want to list all of the elements of <span class="math">\(A \cup B\)</span>, you can list all the elements of <span class="math">\(A\)</span> and then all the elements of <span class="math">\(B\)</span>. And if <span class="math">\(A\)</span> and <span class="math">\(B\)</span> have no elements in common, then to count the elements of <span class="math">\(A \cup B\)</span>, you can count the elements of <span class="math">\(A\)</span> and then continue counting the elements of <span class="math">\(B\)</span>. Once you are comfortable translating the intuitive argument into a precise mathematical proof (and mathematicians generally are), you can use the more intuitive descriptions (and mathematicians generally do).</p>
<p>Here is another basic counting principle:</p>
<hr class="docutils" />
<p><strong>Theorem.</strong> Let <span class="math">\(A\)</span> and <span class="math">\(B\)</span> be finite sets. Then <span class="math">\(| A \times B | = | A | \cdot | B |\)</span>.</p>
<hr class="docutils" />
<p>Notice that this time we are counting the number of ordered pairs <span class="math">\((a, b)\)</span> with <span class="math">\(a \in A\)</span> and <span class="math">\(b \in B\)</span>. The exercises ask you to give a detailed proof of this theorem. There are at least two ways to go about it. The first is to start with bijections <span class="math">\(f : [m] \to A\)</span> and <span class="math">\(g : [n] \to B\)</span> and describe an explicit bijection <span class="math">\(h : [m \cdot n] \to A \times B\)</span>. The second is to fix <span class="math">\(m\)</span>, say, and use induction on <span class="math">\(n\)</span> and the previous counting principle. Notice that if <span class="math">\(U\)</span> and <span class="math">\(V\)</span> are any sets and <span class="math">\(w\)</span> is not in <span class="math">\(V\)</span>, we have</p>
<div class="math">
\[U \times (V \cup \{ w \}) = (U \times V) \cup (U \times \{w\}),\]</div>
<p>and the two sets in this union are disjoint.</p>
<p>Just as we have notions of union <span class="math">\(\bigcup_{i\in I} A_i\)</span> and intersection <span class="math">\(\bigcap_{i \in I} A_i\)</span> for indexed families of sets, it is useful to have a notion of a product <span class="math">\(\prod_{i \in I} A_i\)</span>. We can think of an element <span class="math">\(a\)</span> of this product as a function which, for each element <span class="math">\(i \in I\)</span>, returns an element <span class="math">\(a_i \in A_i\)</span>. For example, when <span class="math">\(I = \{1, 2, 3\}\)</span>, an element of <span class="math">\(\prod_{i \in I} A_i\)</span> is just a triple <span class="math">\(a_1, a_2, a_3\)</span> with <span class="math">\(a_1 \in A_1\)</span>, <span class="math">\(a_2 \in A_2\)</span>, and <span class="math">\(a_3 \in A_3\)</span>. This is essentially the same as <span class="math">\(A_1 \times A_2 \times A_3\)</span>, up to the fiddly details as to whether we represent a triple as a function or with iterated pairing <span class="math">\((a_1, (a_2, a_3))\)</span>.</p>
<hr class="docutils" />
<p><strong>Theorem.</strong> Let <span class="math">\(I\)</span> be a finite index set, and let <span class="math">\((A_i)_{i \in I}\)</span> be a family of finite sets. Then:</p>
<ul class="simple">
<li>If each pair of sets <span class="math">\(A_i\)</span>, <span class="math">\(A_j\)</span> are disjoint, then <span class="math">\(|\bigcup_{i \in I} A_i| = \sum_{i \in I} | A_i |\)</span>.</li>
<li><span class="math">\(| \prod_{i \in I} A_i | = \prod_{i \in I} | A_i |\)</span>.</li>
</ul>
<p><strong>Proof.</strong> By induction on <span class="math">\(|I|\)</span>, using the previous counting principles.</p>
<hr class="docutils" />
<p>We can already use these principles to carry out basic calculations.</p>
<hr class="docutils" />
<p><strong>Example.</strong> The dessert menu at a restaurant has four flavors of ice cream, two kinds of cake, and three kinds of pie. How many dessert choices are there?</p>
<p><strong>Solution.</strong> <span class="math">\(4 + 2 + 3 = 9\)</span>, the cardinality of the union of the three disjoint sets.</p>
<p><strong>Example.</strong> The menu at a diner has 6 choices of appetizers, 7 choices of entr&#233;e, and 5 choices of dessert. How many choices of three-course dinners are there?</p>
<p><strong>Solution.</strong> A three-course dinner is a triple consisting of an appetizer, an entr&#233;e, and a dessert. There are therefore <span class="math">\(6 \cdot 7 \cdot 5 = 210\)</span> options.</p>
<hr class="docutils" />
<p>A special case of the previous counting principles arises when all the sets have the same size. If <span class="math">\(I\)</span> has cardinality <span class="math">\(k\)</span> and each <span class="math">\(A_i\)</span> has cardinality <span class="math">\(n\)</span>, then the cardinality of <span class="math">\(\bigcup_{i \in I} A_i\)</span> is <span class="math">\(k \cdot n\)</span> if the sets are pairwise disjoint, and the cardinality of <span class="math">\(\prod_{i \in I} A_i\)</span> is <span class="math">\(n^k\)</span>.</p>
<hr class="docutils" />
<p><strong>Example.</strong> A deck of playing cards has four suits (diamonds, hearts, spades, and clubs) and 13 cards in each suit, for a total of <span class="math">\(4 \cdot 13 = 52\)</span>.</p>
<p><strong>Example.</strong> A binary string of length <span class="math">\(n\)</span> is a sequence of <span class="math">\(n\)</span> many 0&#8217;s and 1&#8217;s. We can think of this as an element of</p>
<div class="math">
\[\{0, 1\}^n = \prod_{i &lt; n} \{0, 1\},\]</div>
<p>so there are <span class="math">\(2^n\)</span> many binary strings of length <span class="math">\(n\)</span>.</p>
<hr class="docutils" />
<p>There is another counting principle that is almost too obvious to mention: if <span class="math">\(A\)</span> is a finite set and there is a bijection between <span class="math">\(A\)</span> and <span class="math">\(B\)</span>, then <span class="math">\(B\)</span> is also finite, and <span class="math">\(|A| = |B|\)</span>.</p>
<hr class="docutils" />
<p><strong>Example.</strong> Consider the power set of <span class="math">\([n]\)</span>, that is, the collection of all subsets of <span class="math">\(\{0, 1, 2, \ldots, n-1\}\)</span>. There is a one-to-one correspondence between subsets and binary strings of length <span class="math">\(n\)</span>, where element <span class="math">\(i\)</span> of the string is <span class="math">\(1\)</span> if <span class="math">\(i\)</span> is in the set and <span class="math">\(0\)</span> otherwise. As a result, we have <span class="math">\(| \mathcal P ([n]) | = 2^n\)</span>.</p>
</div>
<hr class="docutils" />
<div class="section" id="ordered-selections">
<h2>20.3. Ordered Selections<a class="headerlink" href="#ordered-selections" title="Permalink to this headline">&#182;</a></h2>
<p>Let <span class="math">\(S\)</span> be a finite set, which we will think of as being a set of options, such as items on a menu or books that can be selected from a shelf. We now turn to a family of problems in combinatorics that involves making repeated selections from that set of options. In each case, there are finitely many selections, and the order counts: there is a first choice, a second one, a third one, and so on.</p>
<p>In the first variant of the problem, you are allowed to repeat a choice. For example, if you are choosing 3 flavors from a list of 31 ice cream flavors, you can choose &#8220;chocolate, vanilla, chocolate.&#8221; This is known as <em>ordered selection with repetition</em>. If you are making <span class="math">\(k\)</span> choices from among <span class="math">\(n\)</span> options in <span class="math">\(S\)</span>, such a selection is essentially a tuple <span class="math">\((a_0, a_1, \ldots, a_{k-1})\)</span>, where each <span class="math">\(a_i\)</span> is one of the <span class="math">\(n\)</span> elements in <span class="math">\(S\)</span>. In other words, the set of ways of making <span class="math">\(k\)</span> selections from <span class="math">\(S\)</span> with repetition is the set <span class="math">\(S^k\)</span>, and we have seen in the last section that if <span class="math">\(S\)</span> has cardinality <span class="math">\(n\)</span>, the set <span class="math">\(S^k\)</span> has cardinality <span class="math">\(n^k\)</span>.</p>
<hr class="docutils" />
<p><strong>Theorem.</strong> Let <span class="math">\(S\)</span> be a set of <span class="math">\(n\)</span> elements. Then the number of ways of making <span class="math">\(k\)</span> selections from <span class="math">\(S\)</span> with repetition allowed is <span class="math">\(n^k\)</span>.</p>
<p><strong>Example.</strong> How many three-letter strings (like &#8220;xyz,&#8221; &#8220;qqa,&#8221; &#8230;) can be formed using the twenty-six letters of the alphabet?</p>
<p><strong>Solution.</strong> We have to make three selections from a set of 26 elements, for a total of <span class="math">\(26^3 = 17,576\)</span> possibilities.</p>
<hr class="docutils" />
<p>Suppose instead we wish to make <span class="math">\(k\)</span> ordered selections, but we are not allowed to repeat ourselves. This would arise, from example, if a museum had 26 paintings in its storeroom, and has to select three of them to put on display, ordered from left to right along a wall. There are 26 choices for the first position. Once we have made that choice, 25 remain for the second position, and then 24 remain for the third. So it seems clear that there are <span class="math">\(26 \cdot 25 \cdot 24\)</span> arrangements overall.</p>
<p>Let us try to frame the problem in mathematical terms. We can think of an ordered selection of <span class="math">\(k\)</span> elements from a set <span class="math">\(S\)</span> without repetition as being an <em>injective function</em> <span class="math">\(f\)</span> from <span class="math">\([k]\)</span> to <span class="math">\(S\)</span>. The element <span class="math">\(f(0)\)</span> is the first choice; <span class="math">\(f(1)\)</span> is the second choice, which has to be distinct from <span class="math">\(f(0)\)</span>; <span class="math">\(f(2)\)</span> is the third choice, which has to be distinct from <span class="math">\(f(0)\)</span> and <span class="math">\(f(1)\)</span>; and so on.</p>
<hr class="docutils" />
<p><strong>Theorem.</strong> Let <span class="math">\(A\)</span> and <span class="math">\(B\)</span> be finite sets, with <span class="math">\(|A| = k\)</span> and <span class="math">\(|B| = n\)</span>, and <span class="math">\(k \le n\)</span>. The number of injective functions from <span class="math">\(A\)</span> to <span class="math">\(B\)</span> is <span class="math">\(n \cdot (n - 1) \cdot \ldots \cdot (n - k + 1)\)</span>.</p>
<p><strong>Proof.</strong> Using induction on <span class="math">\(k\)</span>, we will show that for every <span class="math">\(A\)</span>, <span class="math">\(B\)</span>, and <span class="math">\(n \geq k\)</span>, the claim holds. When <span class="math">\(k = 0\)</span> there is only one injective function, namely the function with empty domain. Suppose <span class="math">\(A\)</span> has cardinality <span class="math">\(k + 1\)</span>, let <span class="math">\(a_0\)</span> be any element of <span class="math">\(A\)</span>. Then any injective function from <span class="math">\(A\)</span> to <span class="math">\(B\)</span> can be obtained by choosing an element <span class="math">\(b_0\)</span> for the image of <span class="math">\(a_0\)</span>, and then choosing an injective function from <span class="math">\(A \setminus \{ a_0 \}\)</span> to <span class="math">\(B \setminus \{ b_0 \}\)</span>. There are <span class="math">\(n\)</span> choices of <span class="math">\(b_0\)</span>, and since <span class="math">\(| A \setminus \{ a_0 \} | = n - 1\)</span> and <span class="math">\(|B \setminus \{ b_0 \} | = k - 1\)</span>, there are <span class="math">\((n - 1) \cdot \ldots \cdot (n - k + 1)\)</span> choices of the injective function, by the inductive hypothesis.</p>
<p><strong>Theorem.</strong> Let <span class="math">\(S\)</span> be a finite set, with <span class="math">\(|S| = n\)</span>. Then the number of ways of making <span class="math">\(k\)</span> selections from <span class="math">\(S\)</span> without repetition allowed is <span class="math">\(n \cdot (n - 1) \cdot \ldots \cdot (n - k + 1)\)</span>.</p>
<p><strong>Proof.</strong> This is just a restatement of the previous theorem, where <span class="math">\(A = [k]\)</span> and <span class="math">\(B = S\)</span>.</p>
<hr class="docutils" />
<p>If <span class="math">\(A\)</span> is a finite set, a bijection <span class="math">\(f\)</span> from <span class="math">\(A\)</span> to <span class="math">\(A\)</span> is also called a <em>permutation</em> of <span class="math">\(A\)</span>. The previous theorem shows that if <span class="math">\(|A| = n\)</span> then the number of permutations of <span class="math">\(A\)</span> is <span class="math">\(n \cdot (n - 1) \cdot \ldots \cdot 1\)</span>. This quantity comes up so often that it has a name, <span class="math">\(n\)</span> <em>factorial</em>, and a special notation, <span class="math">\(n!\)</span>. If we think of the elements of <span class="math">\(A\)</span> listed in some order, a permutation of <span class="math">\(A\)</span> is essentially an ordered selection of <span class="math">\(n\)</span> elements from <span class="math">\(A\)</span> without repetition: we choose where to map the first element, then the second element, and so on. It is a useful convention to take <span class="math">\(0!\)</span> to be equal to <span class="math">\(1\)</span>.</p>
<p>The more general case where we are choosing only <span class="math">\(k\)</span> elements from a set <span class="math">\(A\)</span> is called a <span class="math">\(k\)</span>-permutation of <span class="math">\(A\)</span>. The theorem above says that the number of <span class="math">\(k\)</span>-permutations of an <span class="math">\(n\)</span>-element set is equal to <span class="math">\(n! / (n - k)!\)</span>, because if you expand the numerator and denominator into products and cancel, you get exactly the <span class="math">\(n \cdot (n - 1) \cdot \ldots \cdot (n - k + 1)\)</span>. This number is often denoted <span class="math">\(P(n, k)\)</span> or <span class="math">\(P^n_k\)</span>, or some similar variant. So we have <span class="math">\(P(n, k) = n! / (n - k)!\)</span>. Notice that the expression on the right side of the equality provides an efficient way of writing the value of <span class="math">\(P(n, k)\)</span>, but an inefficient way of calculating it.</p>
</div>
<div class="section" id="combinations-and-binomial-coefficients">
<span id="id3"></span><h2>20.4. Combinations and Binomial Coefficients<a class="headerlink" href="#combinations-and-binomial-coefficients" title="Permalink to this headline">&#182;</a></h2>
<p>In the last section, we calculated the number of ways in which a museum could arrange three paintings along a wall, chosen from among 26 paintings in its storeroom. By the final observation in the previous section, we can write this number as <span class="math">\(26! / 23!\)</span>.</p>
<p>Suppose now we want to calculate the number of ways that a museum can choose three paintings from its storeroom to put on display, where we do not care about the order. In other words, if <span class="math">\(a\)</span>, <span class="math">\(b\)</span>, and <span class="math">\(c\)</span> are paintings, we do not want to distinguish between choosing <span class="math">\(a\)</span> then <span class="math">\(b\)</span> then <span class="math">\(c\)</span> and choosing <span class="math">\(c\)</span> then <span class="math">\(b\)</span> then <span class="math">\(a\)</span>. When we were arranging paintings along all wall, it made sense to consider these two different arrangements, but if we only care about the <em>set</em> of elements we end up with at the end, the order that we choose them does not matter.</p>
<p>The problem is that each set of three paintings will be counted multiple times. In fact, each one will be counted six times: there are <span class="math">\(3! = 6\)</span> permutations of the set <span class="math">\(\{a, b, c\}\)</span>, for example. So to count the number of outcomes we simply need to divide by 6. In other words, the number we want is <span class="math">\(\frac{26!}{3! \cdot 23!}\)</span>.</p>
<p>There is nothing special about the numbers <span class="math">\(26\)</span> and <span class="math">\(3\)</span>. The same formula holds for what we will call <em>unordered selections of</em> <span class="math">\(k\)</span> <em>elements from a set of</em> <span class="math">\(n\)</span> <em>elements</em>, or <span class="math">\(k\)</span>-<em>combinations from an</em> <span class="math">\(n\)</span>-<em>element set</em>. Our goal is once again to describe the situation in precise mathematical terms, at which point we will be able to state the formula as a theorem.</p>
<p>In fact, describing the situation in more mathematical terms is quite easy to do. If <span class="math">\(S\)</span> is a set of <span class="math">\(n\)</span> elements, an unordered selection of <span class="math">\(k\)</span> elements from <span class="math">\(S\)</span> is just a subset of <span class="math">\(S\)</span> that has cardinality <span class="math">\(k\)</span>.</p>
<hr class="docutils" />
<p><strong>Theorem.</strong> Let <span class="math">\(S\)</span> be any set with cardinality <span class="math">\(n\)</span>, and let <span class="math">\(k \leq n\)</span>. Then the number of subsets of <span class="math">\(S\)</span> of cardinality <span class="math">\(k\)</span> is <span class="math">\(\frac{n!}{k!(n-k)!}\)</span>.</p>
<p><strong>Proof.</strong> Let <span class="math">\(U\)</span> be the set of unordered selections of <span class="math">\(k\)</span> elements from <span class="math">\(S\)</span>, let <span class="math">\(V\)</span> be the set of permutations of <span class="math">\([k]\)</span>, and let <span class="math">\(W\)</span> be the set of <em>ordered</em> selections of <span class="math">\(k\)</span> elements from <span class="math">\(S\)</span>. There is a bijection between <span class="math">\(U \times V\)</span> and <span class="math">\(W\)</span>, as follows. Suppose we assign to every <span class="math">\(k\)</span>-element subset <span class="math">\(\{ a_0, \ldots, a_{k-1} \}\)</span> of <span class="math">\(S\)</span> some way of listing the elements, as shown. Then given any such set and any permutation <span class="math">\(f\)</span> of <span class="math">\([k]\)</span>, we get an ordered the ordered selection <span class="math">\((a_{f(0)}, a_{f(1)}, \ldots, a_{f(k-1)})\)</span>. Any ordered selection arises from such a subset and a suitable permutation, so the mapping is surjective. And a different set or a different permutation results in a different ordered selection, so the mapping is injective.</p>
<p>By the counting principles, we have</p>
<div class="math">
\[P(n, k) = |W| = |U \times V| = |U| \cdot |V| = |U| \cdot k!,\]</div>
<p>so we have <span class="math">\(|U| = P(n,k) / k! = \frac{n!}{k!(n-k)!}\)</span>.</p>
<p><strong>Example.</strong> Someone is going on vacation and wants to choose three outfits from ten in their closet to pack in their suitcase. How many choices do they have?</p>
<p><strong>Solution.</strong> <span class="math">\(\frac{10!}{3! 7!} = \frac{10 \cdot 9 \cdot 8}{3 \cdot 2 \cdot 1} = 120\)</span>.</p>
<hr class="docutils" />
<p>The number of unordered selections of <span class="math">\(k\)</span> elements from a set of size <span class="math">\(n\)</span>, or, equivalently, the number of <span class="math">\(k\)</span>-combinations from an <span class="math">\(n\)</span>-element set, is typically denoted by <span class="math">\(\binom{n}{k}\)</span>, <span class="math">\(C(n, k)\)</span>, <span class="math">\(C^n_k\)</span>, or something similar. We will use the first notation, because it is most common. Notice that <span class="math">\(\binom{n}0 = 1\)</span> for every <span class="math">\(n\)</span>; this makes sense, because there is exactly one subset of any <span class="math">\(n\)</span>-element set of cardinality <span class="math">\(0\)</span>.</p>
<p>Here is one important property of this function.</p>
<hr class="docutils" />
<p><strong>Theorem.</strong> For every <span class="math">\(n\)</span> and <span class="math">\(k \leq n\)</span>, we have <span class="math">\(\binom{n}{k} = \binom{n}{n - k}\)</span>.</p>
<p><strong>Proof.</strong> This is an easy calculation:</p>
<div class="math">
\[\frac{n!}{(n - k)! (n - (n - k))!} = \frac{n!}{(n - k)! k!}.\]</div>
<p>But it is also easy to see from the combinatorial interpretation: choosing <span class="math">\(k\)</span> outfits from <span class="math">\(n\)</span> to take on vacation is the same task as choosing <span class="math">\(n - k\)</span> outfits to leave home.</p>
<hr class="docutils" />
<p>Here is another important property.</p>
<hr class="docutils" />
<p><strong>Theorem.</strong> For every <span class="math">\(n\)</span> and <span class="math">\(k\)</span>, if <span class="math">\(k + 1 \leq n\)</span>,
then</p>
<div class="math">
\[\binom{n+1}{k+1} = \binom{n}{k+1} + \binom{n}{k}.\]</div>
<p><strong>Proof.</strong> One way to understand this theorem is in terms of the combinatorial interpretation. Suppose you want to choose <span class="math">\(k+1\)</span> outfits out of <span class="math">\(n + 1\)</span>. Set aside one outfit, say, the blue one. Then you have two choices: you can either choose <span class="math">\(k+1\)</span> outfits from the remaining ones, with <span class="math">\(\binom{n}{k+1}\)</span> possibilities; or you can take the blue one, and choose <span class="math">\(k\)</span> outfits from the remaining ones.</p>
<p>The theorem can also be proved by direct calculation. We can express the left-hand side of the equation as follows:</p>
<div class="math">
\[\begin{split}\binom{n+1}{k+1} &amp; = \frac{(n + 1)!}{(k+1)!((n+1)-(k+1))!} \\ &amp; = \frac{(n + 1)!}{(k+1)!(n - k)!}.\end{split}\]</div>
<p>Similarly, we can simplify the right-hand side:</p>
<div class="math">
\[\begin{split}\binom{n}{k+1} + \binom{n}{k} &amp; = \frac{n!}{(k+1)!(n-(k+1))!} + \frac{n!}{k!(n-k)!} \\
&amp; = \frac{n!(n-k)}{(k+1)!(n-k-1)!(n-k)} + \frac{(k+1)n!}{(k+1)k!(n-k)!} \\
&amp; = \frac{n!(n-k)}{(k+1)!(n-k)!} + \frac{(k+1)n!}{(k+1)!(n-k)!} \\
&amp; = \frac{n!(n-k + k + 1)}{(k+1)!(n-k)!} \\
&amp; = \frac{n!(n + 1)}{(k+1)!(n-k)!} \\
&amp; = \frac{(n + 1)!}{(k+1)!(n-k)!}.\end{split}\]</div>
<p>Thus the left-hand side and the right-hand side are equal.</p>
<hr class="docutils" />
<p>For every <span class="math">\(n\)</span>, we know <span class="math">\(\binom{n}{0} = \binom{n}{n} = 1\)</span>. The previous theorem then gives a recipe to compute all the binomial coefficients: once we have determine <span class="math">\(\binom{n}{k}\)</span> for some <span class="math">\(n\)</span> and every <span class="math">\(k \leq n\)</span>, we can determine the values of <span class="math">\(\binom{n+1}{k}\)</span> for every <span class="math">\(k \leq n + 1\)</span> using the recipe above. The results can be displayed graphically in what is known as <em>Pascal&#8217;s triangle</em>:</p>
<img src="_static/combinatorics.1.png"><p>Specifically, if we start counting at <span class="math">\(0\)</span>, the <span class="math">\(k\)</span>th element of the <span class="math">\(n\)</span>th row is equal to <span class="math">\(\binom{n}{k}\)</span>.</p>
<p>There is also a connection between <span class="math">\(\binom{n}{k}\)</span> and the polynomials <span class="math">\((a + b)^n\)</span>, namely, that the <span class="math">\(k\)</span>th coefficient of <span class="math">\((a + b)^n\)</span> is exactly <span class="math">\(\binom{n}{k}\)</span>. For example, we have</p>
<div class="math">
\[(a + b)^4 = a^4 + 4 a^3 b + 6 a^2 b^2 + 4 a b^3 + b^4.\]</div>
<p>For that reason, the values <span class="math">\(\binom{n}{k}\)</span> are often called <em>binomial coefficients</em>, and the statement that</p>
<div class="math">
\[(a + b)^n = \sum_{k \le n} \binom{n}{k} a^{n-k} b^k\]</div>
<p>is known as the <em>binomial theorem</em>.</p>
<p>There are a couple of ways of seeing why this theorem holds. One is to expand the polynomial,</p>
<div class="math">
\[(a + b)^n = (a + b) (a + b) \cdots (a + b)\]</div>
<p>and notice that the coefficient of the term <span class="math">\(a^{n-k} b^k\)</span> is equal to the number of ways of taking the summand <span class="math">\(b\)</span> in exactly <span class="math">\(k\)</span> positions, and <span class="math">\(a\)</span> in the remaining <span class="math">\(n - k\)</span> positions. Another way to prove the result is to use induction on <span class="math">\(n\)</span>, and use the identity <span class="math">\(\binom{n+1}{k+1} = \binom{n}{k+1} + \binom{n}{k}\)</span>. The details are left as an exercise.</p>
<p>Finally, we have considered ordered selections with and without repetitions, and unordered selections without repetitions. What about unordered selections with repetitions? In other words, given a set <span class="math">\(S\)</span> with <span class="math">\(n\)</span> elements, we would like to know how many ways there are of making <span class="math">\(k\)</span> choices, where we can choose elements of <span class="math">\(S\)</span> repeatedly, but we only care about the number of times each element was chosen, and not the order. We have the following:</p>
<hr class="docutils" />
<p>The number of unordered selections of <span class="math">\(k\)</span> elements from an <span class="math">\(n\)</span>-element set, with repetition, is <span class="math">\(\binom{n + k - 1}{k}\)</span>.</p>
<hr class="docutils" />
<p>A proof of this is outlined in the exercises.</p>
</div>
<div class="section" id="the-inclusion-exclusion-principle">
<h2>20.5. The Inclusion-Exclusion Principle<a class="headerlink" href="#the-inclusion-exclusion-principle" title="Permalink to this headline">&#182;</a></h2>
<p>Let <span class="math">\(A\)</span> and <span class="math">\(B\)</span> be any two subsets of some domain, <span class="math">\(U\)</span>. Then <span class="math">\(A = A \setminus B \cup (A \cap B)\)</span>, and the two sets in the union are disjoint, so we have <span class="math">\(|A| = |A \setminus B| + |A \cap B|\)</span>. This means <span class="math">\(|A \setminus B| = |A| - |A \cap B|\)</span>. Intuitively, this makes sense: we can count the elements of <span class="math">\(A \setminus B\)</span> by counting the elements in <span class="math">\(A\)</span>, and then subtracting the number of elements that are in both <span class="math">\(A\)</span> and <span class="math">\(B\)</span>.</p>
<p>Similarly, we have <span class="math">\(A \cup B = A \cup (B \setminus A)\)</span>, and the two sets on the right-hand side of this equation are disjoint, so we
have</p>
<div class="math">
\[|A \cup B| = |A| + |B \setminus A| = |A| + |B| - |A \cap B|.\]</div>
<p>If we draw a Venn diagram, this makes sense: to count the elements in <span class="math">\(A \cup B\)</span>, we can add the number of elements in <span class="math">\(A\)</span> to the number of elements in <span class="math">\(B\)</span>, but then we have to subtract the number of elements of both.</p>
<p>What happen when there are three sets? To compute <span class="math">\(|A \cup B \cup C|\)</span>, we can start by adding the number of elements in each, and then subtracting the number of elements of <span class="math">\(| A \cap B |\)</span>, <span class="math">\(|A \cap C|\)</span>, and <span class="math">\(|B \cap C|\)</span>, each of which have been double-counted. But thinking about the Venn diagram should help us realize that then we have over-corrected: each element of <span class="math">\(A \cap B \cap C\)</span> was counted three times in the original sum, and the subtracted three times. So we need to add them back in:</p>
<div class="math">
\[| A \cup B \cup C | = | A | + | B | + | C | - | A \cap B | - | A \cap C | - | B \cap C | + | A \cap B \cap C |.\]</div>
<p>This generalizes to any number of sets. To state the general result, suppose the sets are numbered <span class="math">\(A_0, \ldots, A_{n-1}\)</span>. For each nonempty subset <span class="math">\(I\)</span> of <span class="math">\(\{0, \ldots, n-1 \}\)</span>, consider <span class="math">\(\bigcap_{i \in I} A_i\)</span>. If <span class="math">\(|I|\)</span> is odd (that is, equal to 1, 3, 5, &#8230;) we want to add the cardinality of the intersection; if it is even we want to subtract it. This recipe is expressed compactly by the following formula:</p>
<div class="math">
\[\left| \bigcup_{i &lt; n} A_i \right| = \sum_{\emptyset \ne I \subseteq [n]} (-1)^{|I|} \left| \bigcap_{i \in I} A_i \right| .\]</div>
<p>You are invited to try proving this as an exercise, if you are ambitious. The following example illustrates its use:</p>
<hr class="docutils" />
<p><strong>Example.</strong> Among a group of college Freshmen, 30 are taking Logic, 25 are taking History, and 20 are taking French. Moreover, 11 are taking Logic and History, 10 are taking Logic and French, 7 are taking History and French, and 3 are taking all three. How many students are taking at least one of the three classes?</p>
<p><strong>Solution.</strong> Letting <span class="math">\(L\)</span>, <span class="math">\(H\)</span>, and <span class="math">\(F\)</span> denote the sets of students taking Logic, History, and French, respectively, we have</p>
<div class="math">
\[| L \cup H \cup F | = 30 + 25 + 20 - 11 - 10 - 7 + 3 = 50.\]</div>
</div>
<hr class="docutils" />
<div class="section" id="exercises">
<h2>20.6. Exercises<a class="headerlink" href="#exercises" title="Permalink to this headline">&#182;</a></h2>
<ol class="arabic">
<li><p class="first">Suppose that, at a party, every two people either know each other or don&#8217;t. In other words, &#8220;<span class="math">\(x\)</span> knows <span class="math">\(y\)</span>&#8221; is symmetric. Also, let us ignore the complex question of whether we always know ourselves by restricting attention to the relation between distinct people; in other words, for this problem, take &#8220;<span class="math">\(x\)</span> knows <span class="math">\(y\)</span>&#8221; to be irreflexive as well.</p>
<p>Use the pigeonhole principle (and an additional insight) to show that there must be two people who know exactly the same number of people.</p>
</li>
<li><p class="first">Show that in any set of <span class="math">\(n + 1\)</span> integers, two of them are equivalent modulo <span class="math">\(n\)</span>.</p>
</li>
<li><p class="first">Spell out in detail a proof of the second counting principle in <a class="reference internal" href="#counting-principles"><span class="std std-numref">Section 20.2</span></a>.</p>
</li>
<li><p class="first">An ice cream parlor has 31 flavors of ice cream.</p>
<ol class="loweralpha simple">
<li>Determine how many three-flavor ice-cream cones are possible, if we care about the order and repetitions are allowed. (So choosing chocolate-chocolate-vanilla scoops, from bottom to top, is different from choosing chocolate-vanilla-chocolate.)</li>
<li>Determine how many three flavor ice-cream cones are possible, if we care about the order, but repetitions are not allowed.</li>
<li>Determine how many three flavor ice-cream cones are possible, if we don&#8217;t care about the order, but repetitions are not allowed.</li>
</ol>
</li>
<li><p class="first">A club of 10 people has to elect a president, vice president, and secretary. How many possibilities are there:</p>
<ol class="loweralpha simple">
<li>if no person can hold more than one office?</li>
<li>if anyone can hold any number of those offices?</li>
<li>if anyone can hold up to two offices?</li>
<li>if the president cannot hold another office, but the vice president and secretary may or may not be the same person?</li>
</ol>
</li>
<li><p class="first">How many 7 digit phone numbers are there, if any 7 digits can be used? How many are there is the first digit cannot be 0?</p>
</li>
<li><p class="first">In a class of 20 kindergarten students, two are twins. How many ways are there of lining up the students, so that the twins are standing together?</p>
</li>
<li><p class="first">A woman has 8 murder mysteries sitting on her shelf, and wants to take three of them on a vacation. How many ways can she do this?</p>
</li>
<li><p class="first">In poker, a &#8220;full house&#8221; is a hand with three of one rank and two of another (for example, three kings and two fives). Determine the number of full houses in poker.</p>
</li>
<li><p class="first">We saw in <a class="reference internal" href="#combinations-and-binomial-coefficients"><span class="std std-numref">Section 20.4</span></a> that</p>
<div class="math">
\[\binom{n+1}{k+1} = \binom{n}{k+1} + \binom{n}{k}.\]</div>
<p>Replacing <span class="math">\(k + 1\)</span> by <span class="math">\(k\)</span>, whenever <span class="math">\(1 \leq k \leq n\)</span>, we have</p>
<div class="math">
\[\binom{n+1}{k} = \binom{n}{k} + \binom{n}{k-1}.\]</div>
<p>Use this to show, by induction on <span class="math">\(n\)</span>, that for every <span class="math">\(k \leq n\)</span>, that if <span class="math">\(S\)</span> is any set of <span class="math">\(n\)</span> elements, <span class="math">\(\binom{n}{k}\)</span> is the number of subsets of <span class="math">\(S\)</span> with <span class="math">\(k\)</span> elements.</p>
</li>
<li><p class="first">How many distinct arrangements are there of the letters in the word MISSISSIPPI?</p>
<p>(Hint: this is tricky. First, suppose all the S&#8217;s, I&#8217;s, and P&#8217;s were painted different colors. Then determine how many distinct arrangements of the letters there would be. In the absence of distinguishing colors, determine how many times each configuration appeared in the first count, and divide by that number.</p>
</li>
<li><p class="first">Prove the inclusion exclusion principle.</p>
</li>
<li><p class="first">Use the inclusion exclusion principle to determine the number of integers less than 100 that are divisible by 2, 3, or 5.</p>
</li>
<li><p class="first">Show that the number of <em>unordered</em> selections of <span class="math">\(k\)</span> elements from an <span class="math">\(n\)</span>-element set is <span class="math">\(\binom{n + k - 1}{k}\)</span>.</p>
<p>Hint: consider <span class="math">\([n]\)</span>. We need to choose some number <span class="math">\(i_0\)</span> of 0&#8217;s, some number <span class="math">\(i_1\)</span> of 1&#8217;s, and so on, so that <span class="math">\(i_0 + i_1 + \ldots + i_{n-1} = k\)</span>. Suppose we assign to each such tuple a the following binary sequence: we write down <span class="math">\(i_0\)</span> 0&#8217;s, then a 1, then <span class="math">\(i_1\)</span> <span class="math">\(0's\)</span>, then a 1, then <span class="math">\(i_2\)</span> 0&#8217;s, and so on. The result is a binary sequence of length <span class="math">\(n + k - 1\)</span> with exactly <span class="math">\(k\)</span> 1&#8217;s, and such binary sequence arises from a unique tuple in this way.</p>
</li>
</ol>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="index.html">Logic and Proof</a></h1>








<!-- <h3>Navigation</h3> -->
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="introduction.html">1. Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="propositional_logic.html">2. Propositional Logic</a></li>
<li class="toctree-l1"><a class="reference internal" href="natural_deduction_for_propositional_logic.html">3. Natural Deduction for Propositional Logic</a></li>
<li class="toctree-l1"><a class="reference internal" href="propositional_logic_in_lean.html">4. Propositional Logic in Lean</a></li>
<li class="toctree-l1"><a class="reference internal" href="classical_reasoning.html">5. Classical Reasoning</a></li>
<li class="toctree-l1"><a class="reference internal" href="semantics_of_propositional_logic.html">6. Semantics of Propositional Logic</a></li>
<li class="toctree-l1"><a class="reference internal" href="first_order_logic.html">7. First Order Logic</a></li>
<li class="toctree-l1"><a class="reference internal" href="natural_deduction_for_first_order_logic.html">8. Natural Deduction for First Order Logic</a></li>
<li class="toctree-l1"><a class="reference internal" href="first_order_logic_in_lean.html">9. First Order Logic in Lean</a></li>
<li class="toctree-l1"><a class="reference internal" href="semantics_of_first_order_logic.html">10. Semantics of First Order Logic</a></li>
<li class="toctree-l1"><a class="reference internal" href="sets.html">11. Sets</a></li>
<li class="toctree-l1"><a class="reference internal" href="sets_in_lean.html">12. Sets in Lean</a></li>
<li class="toctree-l1"><a class="reference internal" href="relations.html">13. Relations</a></li>
<li class="toctree-l1"><a class="reference internal" href="relations_in_lean.html">14. Relations in Lean</a></li>
<li class="toctree-l1"><a class="reference internal" href="functions.html">15. Functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="functions_in_lean.html">16. Functions in Lean</a></li>
<li class="toctree-l1"><a class="reference internal" href="the_natural_numbers_and_induction.html">17. The Natural Numbers and Induction</a></li>
<li class="toctree-l1"><a class="reference internal" href="the_natural_numbers_and_induction_in_lean.html">18. The Natural Numbers and Induction in Lean</a></li>
<li class="toctree-l1"><a class="reference internal" href="elementary_number_theory.html">19. Elementary Number Theory</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">20. Combinatorics</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#finite-sets-and-cardinality">20.1. Finite Sets and Cardinality</a></li>
<li class="toctree-l2"><a class="reference internal" href="#counting-principles">20.2. Counting Principles</a></li>
<li class="toctree-l2"><a class="reference internal" href="#ordered-selections">20.3. Ordered Selections</a></li>
<li class="toctree-l2"><a class="reference internal" href="#combinations-and-binomial-coefficients">20.4. Combinations and Binomial Coefficients</a></li>
<li class="toctree-l2"><a class="reference internal" href="#the-inclusion-exclusion-principle">20.5. The Inclusion-Exclusion Principle</a></li>
<li class="toctree-l2"><a class="reference internal" href="#exercises">20.6. Exercises</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="the_real_numbers.html">21. The Real Numbers</a></li>
<li class="toctree-l1"><a class="reference internal" href="the_infinite.html">22. The Infinite</a></li>
<li class="toctree-l1"><a class="reference internal" href="axiomatic_foundations.html">23. Axiomatic Foundations</a></li>
</ul>


<hr />
<ul>
    
    <li class="toctree-l1"><a href="logic_and_proof.pdf">PDF version</a></li>
    
    <li class="toctree-l1"><a href="https://leanprover.github.io/">Lean Home</a></li>
    
</ul>

<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2017, Jeremy Avigad, Robert Y. Lewis, and Floris van Doorn.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.6.3</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.10</a>
      
      |
      <a href="_sources/combinatorics.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>