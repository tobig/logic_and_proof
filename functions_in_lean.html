
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=ascii" />
    <title>16. Functions in Lean &#8212; Logic and Proof 0.1 documentation</title>
    <link rel="stylesheet" href="_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '0.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="shortcut icon" href="_static/favicon.ico"/>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="17. The Natural Numbers and Induction" href="the_natural_numbers_and_induction.html" />
    <link rel="prev" title="15. Functions" href="functions.html" />
<!-- <link href="https://fonts.googleapis.com/css?family=Sorts+Mill+Goudy" rel="stylesheet"> -->
<!-- <link href="https://fonts.googleapis.com/css?family=Average" rel="stylesheet"> -->
<!-- <link href="https://fonts.googleapis.com/css?family=EB+Garamond" rel="stylesheet"> -->

  </head>
  <body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="functions-in-lean">
<h1>16. Functions in Lean<a class="headerlink" href="#functions-in-lean" title="Permalink to this headline">&#182;</a></h1>
<div class="section" id="functions-and-symbolic-logic">
<h2>16.1. Functions and Symbolic Logic<a class="headerlink" href="#functions-and-symbolic-logic" title="Permalink to this headline">&#182;</a></h2>
<p>Let us now consider functions in formal terms. Even though we have avoided the use of quantifiers and logical symbols in the definitions in the last chapter, by now you should be seeing them lurking beneath the surface. That fact that two functions <span class="math">\(f, g : X \to Y\)</span> are equal if and only if they take the same values at every input can be expressed as follows:</p>
<div class="math">
\[\forall x \in X \; (f(x) = g(x)) \leftrightarrow f = g .\]</div>
<p>This principle is a known as <em>function extensionality</em>, analogous to the principle of extensionality for sets, discussed in <a class="reference internal" href="sets_in_lean.html#sets-in-lean-basics"><span class="std std-numref">Section 12.1</span></a>. Recall that the notation <span class="math">\(\forall x \in X \; P(x)\)</span> abbreviates <span class="math">\(\forall x \; (x \in X \to P(x))\)</span>, and <span class="math">\(\exists x \in X \; P(x)\)</span> abbreviates <span class="math">\(\exists x \; (x \in X \wedge P(x))\)</span>, thereby relativizing the quantifiers to <span class="math">\(X\)</span>.</p>
<p>We can avoid set-theoretic notation if we assume we are working in a logical formalism with basic types for <span class="math">\(X\)</span> and <span class="math">\(Y\)</span>, so that we can specify that <span class="math">\(x\)</span> ranges over <span class="math">\(X\)</span>. In that case, we will write instead</p>
<div class="math">
\[\forall x : X \; (f(x) = g(x) \leftrightarrow f = g)\]</div>
<p>to indicate that the quantification is over <span class="math">\(X\)</span>. Henceforth, we will assume that all our variables range over some type, though we will sometimes omit the types in the quantifiers when they can be inferred from context.</p>
<p>The function <span class="math">\(f\)</span> is injective if it satisfies</p>
<div class="math">
\[\forall x_1, x_2 : X \; (f(x_1) = f(x_2) \to x_1 = x_2),\]</div>
<p>and <span class="math">\(f\)</span> is surjective if</p>
<div class="math">
\[\forall y : Y \; \exists x : X \; f(x) = y.\]</div>
<p>If <span class="math">\(f : X \to Y\)</span> and <span class="math">\(g: Y \to X\)</span>, <span class="math">\(g\)</span> is a left inverse to <span class="math">\(f\)</span> if</p>
<div class="math">
\[\forall x : X \; g(f(x)) = a.\]</div>
<p>Notice that this is a universal statement, and it is equivalent to the statement that <span class="math">\(f\)</span> is a right inverse to <span class="math">\(g\)</span>.</p>
<p>Remember that in logic it is common to use lambda notation to define functions. We can denote the identity function by <span class="math">\(\lambda x \; x\)</span>, or perhaps <span class="math">\(\lambda x : X \; x\)</span> to emphasize that the domain of the function is <span class="math">\(X\)</span>. If <span class="math">\(f : X \to Y\)</span> and <span class="math">\(g : Y \to Z\)</span>, we can define the composition <span class="math">\(g \circ f\)</span> by <span class="math">\(g \circ f = \lambda x : X \; g(f(x))\)</span>.</p>
<p>Also remember that if <span class="math">\(P(x)\)</span> is any predicate, then in first order logic we can assert that there exists a unique <span class="math">\(x\)</span> satisfying <span class="math">\(P(x)\)</span>, written <span class="math">\(\exists! x \; P(x)\)</span>, with the conjunction of the following two statements:</p>
<ul class="simple">
<li><span class="math">\(\exists x \; P(x)\)</span></li>
<li><span class="math">\(\forall x_1, x_2 \; (P(x_1) \wedge P(x_2) \to x_1 = y_1)\)</span></li>
</ul>
<p>Equivalently, we can write</p>
<div class="math">
\[\exists (P(x) \wedge \forall x' \; (P(x') \to x' = x)).\]</div>
<p>Assuming <span class="math">\(\exists! x \; P(x)\)</span>, the following two statements are equivalent:</p>
<ul class="simple">
<li><span class="math">\(\exists x \; (P(x) \wedge Q(x))\)</span></li>
<li><span class="math">\(\forall x \; (P(x) \to Q(x))\)</span></li>
</ul>
<p>and both can be taken to assert that &#8220;the <span class="math">\(x\)</span> satisfying <span class="math">\(P\)</span> also satisfies <span class="math">\(Q\)</span>.&#8221;</p>
<p>A binary relation <span class="math">\(R\)</span> on <span class="math">\(X\)</span> and <span class="math">\(Y\)</span> is functional if it satisfies</p>
<div class="math">
\[\forall x \; \exists! y \; R(x,y).\]</div>
<p>In that case, a logician might use <em>iota notation</em>,</p>
<div class="math">
\[f(x) = \iota y \; R(x, y)\]</div>
<p>to define <span class="math">\(f(x)\)</span> to be equal to the unique <span class="math">\(y\)</span> satisfying <span class="math">\(R(x,y)\)</span>. If <span class="math">\(R\)</span> satisfies the weaker property</p>
<div class="math">
\[\forall x \; \exists y \; R(x,y),\]</div>
<p>a logician might use the <em>Hilbert epsilon</em> to define a function</p>
<div class="math">
\[f(x) = \varepsilon y \; R(x, y)\]</div>
<p>to &#8220;choose&#8221; a value of <span class="math">\(y\)</span> satisfying <span class="math">\(R(x, y)\)</span>. As we have noted above, this is an implicit use of the axiom of choice.</p>
</div>
<div class="section" id="second-and-higher-order-logic">
<h2>16.2. Second- and Higher-Order Logic<a class="headerlink" href="#second-and-higher-order-logic" title="Permalink to this headline">&#182;</a></h2>
<p>In contrast to first-order logic, where we start with a fixed stock of function and relation symbols, the topics we have been considering in the last few chapters encourage us to consider a more expressive language with variables ranging over functions and relations as well. For example, saying that a function <span class="math">\(f : X \to Y\)</span> has a left-inverse implicitly involves a quantifying over functions,</p>
<div class="math">
\[\exists g \; \forall x \; g(f(x)) = x.\]</div>
<p>The theorem that asserts that if any function <span class="math">\(f\)</span> from <span class="math">\(X\)</span> to <span class="math">\(Y\)</span> is injective then it has a left-inverse can be expressed as follows:</p>
<div class="math">
\[\forall x_1, x_2 \; (f(x_1) = f(x_2) \to x_1 = x_2) \to \exists g \; \forall x \; g(f(x)) = x.\]</div>
<p>Similarly, saying that two sets <span class="math">\(X\)</span> and <span class="math">\(Y\)</span> have a one-to-one correspondence asserts the existence of a function <span class="math">\(f : X \to Y\)</span> as well as an inverse to <span class="math">\(f\)</span>. For another example, in <a class="reference internal" href="functions.html#functions-and-relations"><span class="std std-numref">Section 15.4</span></a> we asserted that every functional relation gives rise to a corresponding function, and vice-versa.</p>
<p>What makes these statements interesting is that they involve quantification, both existential and universal, over functions and relations. This takes us outside the realm of first-order logic. One option is to develop a theory in the language of first-order logic in which the universe contains functions and relations as objects; we will see later that this is what axiomatic set theory does. An alternative is to extend first-order logic to involve new kinds of quantifiers and variables, to range over functions and relations. This is what higher-order logic does.</p>
<p>There are various ways to go about this. In view of the relationship between functions and relations described earlier, one can take relations as basic, and define functions in terms of them, or vice-versa. The following formulation of higher-order logic, due to the logician Alonzo Church, follows the latter approach. It is sometimes known as <em>simple type theory</em>.</p>
<p>Start with some basic types, <span class="math">\(X, Y, Z, \ldots\)</span> and a special type, <span class="math">\(\mathrm{Prop}\)</span>, of propositions. Add the following two rules to build new types:</p>
<ul class="simple">
<li>If <span class="math">\(U\)</span> and <span class="math">\(V\)</span> are types, so is <span class="math">\(U \times V\)</span>.</li>
<li>If <span class="math">\(U\)</span> and <span class="math">\(V\)</span> are types, so is <span class="math">\(U \to V\)</span>.</li>
</ul>
<p>The first intended to denote the type of ordered pairs <span class="math">\((u, v)\)</span>, where <span class="math">\(u\)</span> is in <span class="math">\(U\)</span> and <span class="math">\(v\)</span> is in <span class="math">\(V\)</span>. The second is intended to denote the type of functions from <span class="math">\(U\)</span> to <span class="math">\(V\)</span>. Simple type theory now adds the following means of forming expressions:</p>
<ul class="simple">
<li>If <span class="math">\(u\)</span> is of type <span class="math">\(U\)</span> and <span class="math">\(v\)</span> is of type <span class="math">\(V\)</span>, <span class="math">\((u, v)\)</span> is of type <span class="math">\(U \times V\)</span>.</li>
<li>If <span class="math">\(p\)</span> is of type <span class="math">\(U \times V\)</span>, then <span class="math">\((p)_1\)</span> is of type <span class="math">\(U\)</span> and <span class="math">\((p)_2\)</span> if of type <span class="math">\(V\)</span>. (These are intended to denote the first and second element of the pair <span class="math">\(p\)</span>.)</li>
<li>If <span class="math">\(x\)</span> is a variable of type <span class="math">\(U\)</span>, and <span class="math">\(v\)</span> is any expression of type <span class="math">\(V\)</span>, then <span class="math">\(\lambda x \; v\)</span> is of type <span class="math">\(U \to V\)</span>.</li>
<li>If <span class="math">\(f\)</span> is of type <span class="math">\(U \to V\)</span> and <span class="math">\(u\)</span> is of type <span class="math">\(U\)</span>, <span class="math">\(f(u)\)</span> is of type <span class="math">\(V\)</span>.</li>
</ul>
<p>In addition, simple type theory provides all the means we have in first-order logic&#8212;boolean connectives, quantifiers, and equality&#8212;to build propositions.</p>
<p>A function <span class="math">\(f(x, y)\)</span> which takes elements of <span class="math">\(X\)</span> and <span class="math">\(Y\)</span> to a type <span class="math">\(Z\)</span> is viewed as an object of type <span class="math">\(X \times Y \to Z\)</span>. Similarly, a binary relation <span class="math">\(R(x,y)\)</span> on <span class="math">\(X\)</span> and <span class="math">\(Y\)</span> is viewed as an object of type <span class="math">\(X \times Y \to \mathrm{Prop}\)</span>. What makes higher-order logic &#8220;higher order&#8221; is that we can iterate the function type operation indefinitely. For example, if <span class="math">\(\mathbb{N}\)</span> is the type of natural numbers, <span class="math">\(\mathbb{N} \to \mathbb{N}\)</span> denotes the type of functions from the natural numbers to the natural numbers, and <span class="math">\((\mathbb{N} \to \mathbb{N}) \to \mathbb{N}\)</span> denotes the type of functions <span class="math">\(F(f)\)</span> which take a function as argument, and return a natural number.</p>
<p>We have not specified the syntax and rules of higher-order logic very carefully. This is done in a number of more advanced logic textbooks. The fragment of higher-order logic which allows only functions and relations on the basic types (without iterating these constructions) is known as second-order logic.</p>
<p>These notions should seem familiar; we have been using these constructions, with similar notation, in Lean. Indeed, Lean&#8217;s logic is an even more elaborate and expressive system of logic, which fully subsumes all the notions of higher-order logic we have discussed here.</p>
</div>
<div class="section" id="id1">
<h2>16.3. Functions in Lean<a class="headerlink" href="#id1" title="Permalink to this headline">&#182;</a></h2>
<p>The fact that the notions we have been discussing have such a straightforward logical form means that it is easy to define them in Lean. The main difference between the formal representation in Lean and the informal representation above is that, in Lean, we distinguish between a type <code class="docutils literal"><span class="pre">X</span></code> and a subset <code class="docutils literal"><span class="pre">A</span> <span class="pre">:</span> <span class="pre">set</span> <span class="pre">X</span></code> of that type.</p>
<p>In Lean&#8217;s library, composition and identity are defined as follows:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover.github.io/live/3.4.1/#code=namespace%20hidden%0A--%20BEGIN%0Avariables%20%7BX%20Y%20Z%20:%20Type%7D%0A%0Adef%20comp%20(f%20:%20Y%20%E2%86%92%20Z)%20(g%20:%20X%20%E2%86%92%20Y)%20:%20X%20%E2%86%92%20Z%20:=%0A%CE%BBx,%20f%20(g%20x)%0A%0Ainfixr%20%20%60%20%E2%88%98%20%60%20:=%20comp%0A%0Adef%20id%20(x%20:%20X)%20:%20X%20:=%0Ax%0A--%20END%0Aend%20hidden" target="_blank">
try it!</a></div><div class="highlight-lean"><div class="highlight"><pre><span class="kd">variables</span> <span class="o">{</span><span class="n">X</span> <span class="n">Y</span> <span class="n">Z</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span>

<span class="kd">def</span> <span class="n">comp</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">Y</span> <span class="bp">&#8594;</span> <span class="n">Z</span><span class="o">)</span> <span class="o">(</span><span class="n">g</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">&#8594;</span> <span class="n">Y</span><span class="o">)</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">&#8594;</span> <span class="n">Z</span> <span class="o">:=</span>
<span class="bp">&#955;</span><span class="n">x</span><span class="o">,</span> <span class="n">f</span> <span class="o">(</span><span class="n">g</span> <span class="n">x</span><span class="o">)</span>

<span class="kd">infixr</span>  <span class="bp">`</span> <span class="bp">&#8728;</span> <span class="bp">`</span> <span class="o">:=</span> <span class="n">comp</span>

<span class="kd">def</span> <span class="n">id</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">X</span><span class="o">)</span> <span class="o">:</span> <span class="n">X</span> <span class="o">:=</span>
<span class="n">x</span>
</pre></div>
</div>
</div><p>Ordinarily, we use <code class="docutils literal"><span class="pre">funext</span></code> (for &#8220;function extensionality&#8221;) to prove that two functions are equal.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover.github.io/live/3.4.1/#code=variables%20%7BX%20Y%20:%20Type%7D%0A%0A--%20BEGIN%0Aexample%20(f%20g%20:%20X%20%E2%86%92%20Y)%20(h%20:%20%E2%88%80%20x,%20f%20x%20=%20g%20x)%20:%20f%20=%20g%20:=%0Afunext%20h%0A--%20END" target="_blank">
try it!</a></div><div class="highlight-lean"><div class="highlight"><pre><span class="kd">example</span> <span class="o">(</span><span class="n">f</span> <span class="n">g</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">&#8594;</span> <span class="n">Y</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">&#8704;</span> <span class="n">x</span><span class="o">,</span> <span class="n">f</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">g</span> <span class="n">x</span><span class="o">)</span> <span class="o">:</span> <span class="n">f</span> <span class="bp">=</span> <span class="n">g</span> <span class="o">:=</span>
<span class="n">funext</span> <span class="n">h</span>
</pre></div>
</div>
</div><p>But Lean can prove some basic identities by simply unfolding definitions and simplifying expressions, using reflexivity.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover.github.io/live/3.4.1/#code=open%20function%0Avariables%20%7BX%20Y%20Z%20W%20:%20Type%7D%0A%0A--%20BEGIN%0Alemma%20left_id%20(f%20:%20X%20%E2%86%92%20Y)%20:%20id%20%E2%88%98%20f%20=%20f%20:=%20rfl%0A%0Alemma%20right_id%20(f%20:%20X%20%E2%86%92%20Y)%20:%20f%20%E2%88%98%20id%20=%20f%20:=%20rfl%0A%0Atheorem%20comp.assoc%20(f%20:%20Z%20%E2%86%92%20W)%20(g%20:%20Y%20%E2%86%92%20Z)%20(h%20:%20X%20%E2%86%92%20Y)%20:%0A%20%20(f%20%E2%88%98%20g)%20%E2%88%98%20h%20=%20f%20%E2%88%98%20(g%20%E2%88%98%20h)%20:=%20rfl%0A%0Atheorem%20comp.left_id%20(f%20:%20X%20%E2%86%92%20Y)%20:%20id%20%E2%88%98%20f%20=%20f%20:=%20rfl%0A%0Atheorem%20comp.right_id%20(f%20:%20X%20%E2%86%92%20Y)%20:%20f%20%E2%88%98%20id%20=%20f%20:=%20rfl%0A--%20END" target="_blank">
try it!</a></div><div class="highlight-lean"><div class="highlight"><pre><span class="kd">lemma</span> <span class="n">left_id</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">&#8594;</span> <span class="n">Y</span><span class="o">)</span> <span class="o">:</span> <span class="n">id</span> <span class="bp">&#8728;</span> <span class="n">f</span> <span class="bp">=</span> <span class="n">f</span> <span class="o">:=</span> <span class="n">rfl</span>

<span class="kd">lemma</span> <span class="n">right_id</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">&#8594;</span> <span class="n">Y</span><span class="o">)</span> <span class="o">:</span> <span class="n">f</span> <span class="bp">&#8728;</span> <span class="n">id</span> <span class="bp">=</span> <span class="n">f</span> <span class="o">:=</span> <span class="n">rfl</span>

<span class="kd">theorem</span> <span class="n">comp.assoc</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">Z</span> <span class="bp">&#8594;</span> <span class="n">W</span><span class="o">)</span> <span class="o">(</span><span class="n">g</span> <span class="o">:</span> <span class="n">Y</span> <span class="bp">&#8594;</span> <span class="n">Z</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">&#8594;</span> <span class="n">Y</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">(</span><span class="n">f</span> <span class="bp">&#8728;</span> <span class="n">g</span><span class="o">)</span> <span class="bp">&#8728;</span> <span class="n">h</span> <span class="bp">=</span> <span class="n">f</span> <span class="bp">&#8728;</span> <span class="o">(</span><span class="n">g</span> <span class="bp">&#8728;</span> <span class="n">h</span><span class="o">)</span> <span class="o">:=</span> <span class="n">rfl</span>

<span class="kd">theorem</span> <span class="n">comp.left_id</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">&#8594;</span> <span class="n">Y</span><span class="o">)</span> <span class="o">:</span> <span class="n">id</span> <span class="bp">&#8728;</span> <span class="n">f</span> <span class="bp">=</span> <span class="n">f</span> <span class="o">:=</span> <span class="n">rfl</span>

<span class="kd">theorem</span> <span class="n">comp.right_id</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">&#8594;</span> <span class="n">Y</span><span class="o">)</span> <span class="o">:</span> <span class="n">f</span> <span class="bp">&#8728;</span> <span class="n">id</span> <span class="bp">=</span> <span class="n">f</span> <span class="o">:=</span> <span class="n">rfl</span>
</pre></div>
</div>
</div><p>We can define what it means for <span class="math">\(f\)</span> to be injective, surjective, or bijective:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover.github.io/live/3.4.1/#code=variables%20%7BX%20Y%20Z%20:%20Type%7D%0A%0A--%20BEGIN%0Adef%20injective%20(f%20:%20X%20%E2%86%92%20Y)%20:%20Prop%20:=%20%E2%88%80%20%E2%A6%83x%E2%82%81%20x%E2%82%82%E2%A6%84,%20f%20x%E2%82%81%20=%20f%20x%E2%82%82%20%E2%86%92%20x%E2%82%81%20=%20x%E2%82%82%0A%0Adef%20surjective%20(f%20:%20X%20%E2%86%92%20Y)%20:%20Prop%20:=%20%E2%88%80%20y,%20%E2%88%83%20x,%20f%20x%20=%20y%0A%0Adef%20bijective%20(f%20:%20X%20%E2%86%92%20Y)%20:=%20injective%20f%20%E2%88%A7%20surjective%20f%0A--%20END" target="_blank">
try it!</a></div><div class="highlight-lean"><div class="highlight"><pre><span class="kd">def</span> <span class="n">injective</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">&#8594;</span> <span class="n">Y</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="bp">&#8704;</span> <span class="o">&#10627;</span><span class="n">x&#8321;</span> <span class="n">x&#8322;</span><span class="o">&#10628;,</span> <span class="n">f</span> <span class="n">x&#8321;</span> <span class="bp">=</span> <span class="n">f</span> <span class="n">x&#8322;</span> <span class="bp">&#8594;</span> <span class="n">x&#8321;</span> <span class="bp">=</span> <span class="n">x&#8322;</span>

<span class="kd">def</span> <span class="n">surjective</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">&#8594;</span> <span class="n">Y</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="bp">&#8704;</span> <span class="n">y</span><span class="o">,</span> <span class="bp">&#8707;</span> <span class="n">x</span><span class="o">,</span> <span class="n">f</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">y</span>

<span class="kd">def</span> <span class="n">bijective</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">&#8594;</span> <span class="n">Y</span><span class="o">)</span> <span class="o">:=</span> <span class="n">injective</span> <span class="n">f</span> <span class="bp">&#8743;</span> <span class="n">surjective</span> <span class="n">f</span>
</pre></div>
</div>
</div><p>Marking the variables <code class="docutils literal"><span class="pre">x&#8321;</span></code> and <code class="docutils literal"><span class="pre">x&#8322;</span></code> implicit in the definition of <code class="docutils literal"><span class="pre">injective</span></code> means that we do not have to write them as often. Specifically, given <code class="docutils literal"><span class="pre">h</span> <span class="pre">:</span> <span class="pre">injective</span> <span class="pre">f</span></code>, and <code class="docutils literal"><span class="pre">h&#8321;</span> <span class="pre">:</span> <span class="pre">f</span> <span class="pre">x&#8321;</span> <span class="pre">=</span> <span class="pre">f</span> <span class="pre">x&#8322;</span></code>, we write <code class="docutils literal"><span class="pre">h</span> <span class="pre">h&#8321;</span></code> rather than <code class="docutils literal"><span class="pre">h</span> <span class="pre">x&#8321;</span> <span class="pre">x&#8322;</span> <span class="pre">h&#8321;</span></code> to show <code class="docutils literal"><span class="pre">x&#8321;</span> <span class="pre">=</span> <span class="pre">x&#8322;</span></code>.</p>
<p>We can then prove that the identity function is bijective:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover.github.io/live/3.4.1/#code=open%20function%0A%0Anamespace%20hidden%0Avariables%20%7BX%20Y%20Z%20:%20Type%7D%0A%0A%0A--%20BEGIN%0Atheorem%20injective_id%20:%20injective%20(&#64;id%20X)%20:=%0Aassume%20x%E2%82%81%20x%E2%82%82,%0Aassume%20H%20:%20id%20x%E2%82%81%20=%20id%20x%E2%82%82,%0Ashow%20x%E2%82%81%20=%20x%E2%82%82,%20from%20H%0A%0Atheorem%20surjective_id%20:%20surjective%20(&#64;id%20X)%20:=%0Aassume%20y,%0Ashow%20%E2%88%83%20x,%20id%20x%20=%20y,%20from%20exists.intro%20y%20rfl%0A%0Atheorem%20bijective_id%20:%20bijective%20(&#64;id%20X)%20:=%0Aand.intro%20injective_id%20surjective_id%0A--%20END%0A%0Aend%20hidden" target="_blank">
try it!</a></div><div class="highlight-lean"><div class="highlight"><pre><span class="kd">theorem</span> <span class="n">injective_id</span> <span class="o">:</span> <span class="n">injective</span> <span class="o">(</span><span class="bp">@</span><span class="n">id</span> <span class="n">X</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">assume</span> <span class="n">x&#8321;</span> <span class="n">x&#8322;</span><span class="o">,</span>
<span class="k">assume</span> <span class="n">H</span> <span class="o">:</span> <span class="n">id</span> <span class="n">x&#8321;</span> <span class="bp">=</span> <span class="n">id</span> <span class="n">x&#8322;</span><span class="o">,</span>
<span class="k">show</span> <span class="n">x&#8321;</span> <span class="bp">=</span> <span class="n">x&#8322;</span><span class="o">,</span> <span class="k">from</span> <span class="n">H</span>

<span class="kd">theorem</span> <span class="n">surjective_id</span> <span class="o">:</span> <span class="n">surjective</span> <span class="o">(</span><span class="bp">@</span><span class="n">id</span> <span class="n">X</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">assume</span> <span class="n">y</span><span class="o">,</span>
<span class="k">show</span> <span class="bp">&#8707;</span> <span class="n">x</span><span class="o">,</span> <span class="n">id</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">y</span><span class="o">,</span> <span class="k">from</span> <span class="n">exists.intro</span> <span class="n">y</span> <span class="n">rfl</span>

<span class="kd">theorem</span> <span class="n">bijective_id</span> <span class="o">:</span> <span class="n">bijective</span> <span class="o">(</span><span class="bp">@</span><span class="n">id</span> <span class="n">X</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">and.intro</span> <span class="n">injective_id</span> <span class="n">surjective_id</span>
</pre></div>
</div>
</div><p>More interestingly, we can prove that the composition of injective functions is injective, and so on.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover.github.io/live/3.4.1/#code=open%20function%0A%0Anamespace%20hidden%0Avariables%20%7BX%20Y%20Z%20:%20Type%7D%0A%0A--%20BEGIN%0Atheorem%20injective_comp%20%7Bg%20:%20Y%20%E2%86%92%20Z%7D%20%7Bf%20:%20X%20%E2%86%92%20Y%7D%0A%20%20%20%20(Hg%20:%20injective%20g)%20(Hf%20:%20injective%20f)%20:%0A%20%20injective%20(g%20%E2%88%98%20f)%20:=%0Aassume%20x%E2%82%81%20x%E2%82%82,%0Aassume%20:%20(g%20%E2%88%98%20f)%20x%E2%82%81%20=%20(g%20%E2%88%98%20f)%20x%E2%82%82,%0Ahave%20f%20x%E2%82%81%20=%20f%20x%E2%82%82,%20from%20Hg%20this,%0Ashow%20x%E2%82%81%20=%20x%E2%82%82,%20from%20Hf%20this%0A%0Atheorem%20surjective_comp%20%7Bg%20:%20Y%20%E2%86%92%20Z%7D%20%7Bf%20:%20X%20%E2%86%92%20Y%7D%0A%20%20%20%20(hg%20:%20surjective%20g)%20(hf%20:%20surjective%20f)%20:%0A%20%20surjective%20(g%20%E2%88%98%20f)%20:=%0Aassume%20z,%0Aexists.elim%20(hg%20z)%20$%0Aassume%20y%20(hy%20:%20g%20y%20=%20z),%0Aexists.elim%20(hf%20y)%20$%0Aassume%20x%20(hx%20:%20f%20x%20=%20y),%0Ahave%20g%20(f%20x)%20=%20z,%20from%20eq.subst%20(eq.symm%20hx)%20hy,%0Ashow%20%E2%88%83%20x,%20g%20(f%20x)%20=%20z,%20from%20exists.intro%20x%20this%0A%0Atheorem%20bijective_comp%20%7Bg%20:%20Y%20%E2%86%92%20Z%7D%20%7Bf%20:%20X%20%E2%86%92%20Y%7D%0A%20%20%20%20(hg%20:%20bijective%20g)%20(hf%20:%20bijective%20f)%20:%0A%20%20bijective%20(g%20%E2%88%98%20f)%20:=%0Ahave%20ginj%20:%20injective%20g,%20from%20hg.left,%0Ahave%20gsurj%20:%20surjective%20g,%20from%20hg.right,%0Ahave%20finj%20:%20injective%20f,%20from%20hf.left,%0Ahave%20fsurj%20:%20surjective%20f,%20from%20hf.right,%0Aand.intro%20(injective_comp%20ginj%20finj)%0A%20%20(surjective_comp%20gsurj%20fsurj)%0A--%20END%0A%0Aend%20hidden" target="_blank">
try it!</a></div><div class="highlight-lean"><div class="highlight"><pre><span class="kd">theorem</span> <span class="n">injective_comp</span> <span class="o">{</span><span class="n">g</span> <span class="o">:</span> <span class="n">Y</span> <span class="bp">&#8594;</span> <span class="n">Z</span><span class="o">}</span> <span class="o">{</span><span class="n">f</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">&#8594;</span> <span class="n">Y</span><span class="o">}</span>
    <span class="o">(</span><span class="n">Hg</span> <span class="o">:</span> <span class="n">injective</span> <span class="n">g</span><span class="o">)</span> <span class="o">(</span><span class="n">Hf</span> <span class="o">:</span> <span class="n">injective</span> <span class="n">f</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">injective</span> <span class="o">(</span><span class="n">g</span> <span class="bp">&#8728;</span> <span class="n">f</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">assume</span> <span class="n">x&#8321;</span> <span class="n">x&#8322;</span><span class="o">,</span>
<span class="k">assume</span> <span class="o">:</span> <span class="o">(</span><span class="n">g</span> <span class="bp">&#8728;</span> <span class="n">f</span><span class="o">)</span> <span class="n">x&#8321;</span> <span class="bp">=</span> <span class="o">(</span><span class="n">g</span> <span class="bp">&#8728;</span> <span class="n">f</span><span class="o">)</span> <span class="n">x&#8322;</span><span class="o">,</span>
<span class="k">have</span> <span class="n">f</span> <span class="n">x&#8321;</span> <span class="bp">=</span> <span class="n">f</span> <span class="n">x&#8322;</span><span class="o">,</span> <span class="k">from</span> <span class="n">Hg</span> <span class="n">this</span><span class="o">,</span>
<span class="k">show</span> <span class="n">x&#8321;</span> <span class="bp">=</span> <span class="n">x&#8322;</span><span class="o">,</span> <span class="k">from</span> <span class="n">Hf</span> <span class="n">this</span>

<span class="kd">theorem</span> <span class="n">surjective_comp</span> <span class="o">{</span><span class="n">g</span> <span class="o">:</span> <span class="n">Y</span> <span class="bp">&#8594;</span> <span class="n">Z</span><span class="o">}</span> <span class="o">{</span><span class="n">f</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">&#8594;</span> <span class="n">Y</span><span class="o">}</span>
    <span class="o">(</span><span class="n">hg</span> <span class="o">:</span> <span class="n">surjective</span> <span class="n">g</span><span class="o">)</span> <span class="o">(</span><span class="n">hf</span> <span class="o">:</span> <span class="n">surjective</span> <span class="n">f</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">surjective</span> <span class="o">(</span><span class="n">g</span> <span class="bp">&#8728;</span> <span class="n">f</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">assume</span> <span class="n">z</span><span class="o">,</span>
<span class="n">exists.elim</span> <span class="o">(</span><span class="n">hg</span> <span class="n">z</span><span class="o">)</span> <span class="bp">$</span>
<span class="k">assume</span> <span class="n">y</span> <span class="o">(</span><span class="n">hy</span> <span class="o">:</span> <span class="n">g</span> <span class="n">y</span> <span class="bp">=</span> <span class="n">z</span><span class="o">),</span>
<span class="n">exists.elim</span> <span class="o">(</span><span class="n">hf</span> <span class="n">y</span><span class="o">)</span> <span class="bp">$</span>
<span class="k">assume</span> <span class="n">x</span> <span class="o">(</span><span class="n">hx</span> <span class="o">:</span> <span class="n">f</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">y</span><span class="o">),</span>
<span class="k">have</span> <span class="n">g</span> <span class="o">(</span><span class="n">f</span> <span class="n">x</span><span class="o">)</span> <span class="bp">=</span> <span class="n">z</span><span class="o">,</span> <span class="k">from</span> <span class="n">eq.subst</span> <span class="o">(</span><span class="n">eq.symm</span> <span class="n">hx</span><span class="o">)</span> <span class="n">hy</span><span class="o">,</span>
<span class="k">show</span> <span class="bp">&#8707;</span> <span class="n">x</span><span class="o">,</span> <span class="n">g</span> <span class="o">(</span><span class="n">f</span> <span class="n">x</span><span class="o">)</span> <span class="bp">=</span> <span class="n">z</span><span class="o">,</span> <span class="k">from</span> <span class="n">exists.intro</span> <span class="n">x</span> <span class="n">this</span>

<span class="kd">theorem</span> <span class="n">bijective_comp</span> <span class="o">{</span><span class="n">g</span> <span class="o">:</span> <span class="n">Y</span> <span class="bp">&#8594;</span> <span class="n">Z</span><span class="o">}</span> <span class="o">{</span><span class="n">f</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">&#8594;</span> <span class="n">Y</span><span class="o">}</span>
    <span class="o">(</span><span class="n">hg</span> <span class="o">:</span> <span class="n">bijective</span> <span class="n">g</span><span class="o">)</span> <span class="o">(</span><span class="n">hf</span> <span class="o">:</span> <span class="n">bijective</span> <span class="n">f</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">bijective</span> <span class="o">(</span><span class="n">g</span> <span class="bp">&#8728;</span> <span class="n">f</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">have</span> <span class="n">ginj</span> <span class="o">:</span> <span class="n">injective</span> <span class="n">g</span><span class="o">,</span> <span class="k">from</span> <span class="n">hg.left</span><span class="o">,</span>
<span class="k">have</span> <span class="n">gsurj</span> <span class="o">:</span> <span class="n">surjective</span> <span class="n">g</span><span class="o">,</span> <span class="k">from</span> <span class="n">hg.right</span><span class="o">,</span>
<span class="k">have</span> <span class="n">finj</span> <span class="o">:</span> <span class="n">injective</span> <span class="n">f</span><span class="o">,</span> <span class="k">from</span> <span class="n">hf.left</span><span class="o">,</span>
<span class="k">have</span> <span class="n">fsurj</span> <span class="o">:</span> <span class="n">surjective</span> <span class="n">f</span><span class="o">,</span> <span class="k">from</span> <span class="n">hf.right</span><span class="o">,</span>
<span class="n">and.intro</span> <span class="o">(</span><span class="n">injective_comp</span> <span class="n">ginj</span> <span class="n">finj</span><span class="o">)</span>
  <span class="o">(</span><span class="n">surjective_comp</span> <span class="n">gsurj</span> <span class="n">fsurj</span><span class="o">)</span>
</pre></div>
</div>
</div><p>The notions of left and right inverse are defined in the expected way.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover.github.io/live/3.4.1/#code=variables%20%7BX%20Y%20:%20Type%7D%0A%0Anamespace%20hidden%0A%0A--%20BEGIN%0A--%20g%20is%20a%20left%20inverse%20to%20f%0Adef%20left_inverse%20(g%20:%20Y%20%E2%86%92%20X)%20(f%20:%20X%20%E2%86%92%20Y)%20:%20Prop%20:=%20%E2%88%80%20x,%20g%20(f%20x)%20=%20x%0A%0A--%20g%20is%20a%20right%20inverse%20to%20f%0Adef%20right_inverse%20(g%20:%20Y%20%E2%86%92%20X)%20(f%20:%20X%20%E2%86%92%20Y)%20:%20Prop%20:=%20left_inverse%20f%20g%0A--%20END%0A%0Aend%20hidden" target="_blank">
try it!</a></div><div class="highlight-lean"><div class="highlight"><pre><span class="c1">-- g is a left inverse to f</span>
<span class="kd">def</span> <span class="n">left_inverse</span> <span class="o">(</span><span class="n">g</span> <span class="o">:</span> <span class="n">Y</span> <span class="bp">&#8594;</span> <span class="n">X</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">&#8594;</span> <span class="n">Y</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="bp">&#8704;</span> <span class="n">x</span><span class="o">,</span> <span class="n">g</span> <span class="o">(</span><span class="n">f</span> <span class="n">x</span><span class="o">)</span> <span class="bp">=</span> <span class="n">x</span>

<span class="c1">-- g is a right inverse to f</span>
<span class="kd">def</span> <span class="n">right_inverse</span> <span class="o">(</span><span class="n">g</span> <span class="o">:</span> <span class="n">Y</span> <span class="bp">&#8594;</span> <span class="n">X</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">&#8594;</span> <span class="n">Y</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="n">left_inverse</span> <span class="n">f</span> <span class="n">g</span>
</pre></div>
</div>
</div><p>In particular, composing with a left or right inverse yields the identity.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover.github.io/live/3.4.1/#code=open%20function%0Avariables%20%7BX%20Y%20Z%20:%20Type%7D%0A%0A--%20BEGIN%0Adef%20id_of_left_inverse%20%7Bg%20:%20Y%20%E2%86%92%20X%7D%20%7Bf%20:%20X%20%E2%86%92%20Y%7D%20:%20left_inverse%20g%20f%20%E2%86%92%20g%20%E2%88%98%20f%20=%20id%20:=%0Aassume%20H,%20funext%20H%0A%0Adef%20id_of_right_inverse%20%7Bg%20:%20Y%20%E2%86%92%20X%7D%20%7Bf%20:%20X%20%E2%86%92%20Y%7D%20:%20right_inverse%20g%20f%20%E2%86%92%20f%20%E2%88%98%20g%20=%20id%20:=%0Aassume%20H,%20funext%20H%0A--%20END" target="_blank">
try it!</a></div><div class="highlight-lean"><div class="highlight"><pre><span class="kd">def</span> <span class="n">id_of_left_inverse</span> <span class="o">{</span><span class="n">g</span> <span class="o">:</span> <span class="n">Y</span> <span class="bp">&#8594;</span> <span class="n">X</span><span class="o">}</span> <span class="o">{</span><span class="n">f</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">&#8594;</span> <span class="n">Y</span><span class="o">}</span> <span class="o">:</span> <span class="n">left_inverse</span> <span class="n">g</span> <span class="n">f</span> <span class="bp">&#8594;</span> <span class="n">g</span> <span class="bp">&#8728;</span> <span class="n">f</span> <span class="bp">=</span> <span class="n">id</span> <span class="o">:=</span>
<span class="k">assume</span> <span class="n">H</span><span class="o">,</span> <span class="n">funext</span> <span class="n">H</span>

<span class="kd">def</span> <span class="n">id_of_right_inverse</span> <span class="o">{</span><span class="n">g</span> <span class="o">:</span> <span class="n">Y</span> <span class="bp">&#8594;</span> <span class="n">X</span><span class="o">}</span> <span class="o">{</span><span class="n">f</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">&#8594;</span> <span class="n">Y</span><span class="o">}</span> <span class="o">:</span> <span class="n">right_inverse</span> <span class="n">g</span> <span class="n">f</span> <span class="bp">&#8594;</span> <span class="n">f</span> <span class="bp">&#8728;</span> <span class="n">g</span> <span class="bp">=</span> <span class="n">id</span> <span class="o">:=</span>
<span class="k">assume</span> <span class="n">H</span><span class="o">,</span> <span class="n">funext</span> <span class="n">H</span>
</pre></div>
</div>
</div><p>Notice that we need to use <code class="docutils literal"><span class="pre">funext</span></code> to show the equality of functions.</p>
<p>The following shows that if a function has a left inverse, then it is injective, and if it has a right inverse, then it is surjective.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover.github.io/live/3.4.1/#code=open%20function%0Avariables%20%7BX%20Y%20:%20Type%7D%0A%0A--%20BEGIN%0Atheorem%20injective_of_left_inverse%20%7Bg%20:%20Y%20%E2%86%92%20X%7D%20%7Bf%20:%20X%20%E2%86%92%20Y%7D%20:%0A%20%20left_inverse%20g%20f%20%E2%86%92%20injective%20f%20:=%0Aassume%20h,%20assume%20x%E2%82%81%20x%E2%82%82,%20assume%20feq,%0Acalc%20x%E2%82%81%20=%20g%20(f%20x%E2%82%81)%20:%20by%20rw%20h%0A%20%20%20%20...%20=%20g%20(f%20x%E2%82%82)%20:%20by%20rw%20feq%0A%20%20%20%20...%20=%20x%E2%82%82%20%20%20%20%20%20%20:%20by%20rw%20h%0A%0Atheorem%20surjective_of_right_inverse%20%7Bg%20:%20Y%20%20%E2%86%92%20X%7D%20%7Bf%20:%20X%20%E2%86%92%20Y%7D%20:%0A%20%20right_inverse%20g%20f%20%E2%86%92%20surjective%20f%20:=%0Aassume%20h,%20assume%20y,%0Alet%20%20x%20:%20X%20:=%20g%20y%20in%0Ahave%20f%20x%20=%20y,%20from%20calc%0A%20%20f%20x%20%20=%20(f%20(g%20y))%20%20%20%20:%20rfl%0A%20%20%20...%20=%20y%20%20%20%20%20%20%20%20%20%20%20%20:%20by%20rw%20%5Bh%20y%5D,%0Ashow%20%E2%88%83%20x,%20f%20x%20=%20y,%20from%20exists.intro%20x%20this%0A--%20END" target="_blank">
try it!</a></div><div class="highlight-lean"><div class="highlight"><pre><span class="kd">theorem</span> <span class="n">injective_of_left_inverse</span> <span class="o">{</span><span class="n">g</span> <span class="o">:</span> <span class="n">Y</span> <span class="bp">&#8594;</span> <span class="n">X</span><span class="o">}</span> <span class="o">{</span><span class="n">f</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">&#8594;</span> <span class="n">Y</span><span class="o">}</span> <span class="o">:</span>
  <span class="n">left_inverse</span> <span class="n">g</span> <span class="n">f</span> <span class="bp">&#8594;</span> <span class="n">injective</span> <span class="n">f</span> <span class="o">:=</span>
<span class="k">assume</span> <span class="n">h</span><span class="o">,</span> <span class="k">assume</span> <span class="n">x&#8321;</span> <span class="n">x&#8322;</span><span class="o">,</span> <span class="k">assume</span> <span class="n">feq</span><span class="o">,</span>
<span class="k">calc</span> <span class="n">x&#8321;</span> <span class="bp">=</span> <span class="n">g</span> <span class="o">(</span><span class="n">f</span> <span class="n">x&#8321;</span><span class="o">)</span> <span class="o">:</span> <span class="kd">by</span> <span class="n">rw</span> <span class="n">h</span>
    <span class="bp">...</span> <span class="bp">=</span> <span class="n">g</span> <span class="o">(</span><span class="n">f</span> <span class="n">x&#8322;</span><span class="o">)</span> <span class="o">:</span> <span class="kd">by</span> <span class="n">rw</span> <span class="n">feq</span>
    <span class="bp">...</span> <span class="bp">=</span> <span class="n">x&#8322;</span>       <span class="o">:</span> <span class="kd">by</span> <span class="n">rw</span> <span class="n">h</span>

<span class="kd">theorem</span> <span class="n">surjective_of_right_inverse</span> <span class="o">{</span><span class="n">g</span> <span class="o">:</span> <span class="n">Y</span>  <span class="bp">&#8594;</span> <span class="n">X</span><span class="o">}</span> <span class="o">{</span><span class="n">f</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">&#8594;</span> <span class="n">Y</span><span class="o">}</span> <span class="o">:</span>
  <span class="n">right_inverse</span> <span class="n">g</span> <span class="n">f</span> <span class="bp">&#8594;</span> <span class="n">surjective</span> <span class="n">f</span> <span class="o">:=</span>
<span class="k">assume</span> <span class="n">h</span><span class="o">,</span> <span class="k">assume</span> <span class="n">y</span><span class="o">,</span>
<span class="k">let</span>  <span class="n">x</span> <span class="o">:</span> <span class="n">X</span> <span class="o">:=</span> <span class="n">g</span> <span class="n">y</span> <span class="k">in</span>
<span class="k">have</span> <span class="n">f</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">y</span><span class="o">,</span> <span class="k">from</span> <span class="k">calc</span>
  <span class="n">f</span> <span class="n">x</span>  <span class="bp">=</span> <span class="o">(</span><span class="n">f</span> <span class="o">(</span><span class="n">g</span> <span class="n">y</span><span class="o">))</span>    <span class="o">:</span> <span class="n">rfl</span>
   <span class="bp">...</span> <span class="bp">=</span> <span class="n">y</span>            <span class="o">:</span> <span class="kd">by</span> <span class="n">rw</span> <span class="o">[</span><span class="n">h</span> <span class="n">y</span><span class="o">],</span>
<span class="k">show</span> <span class="bp">&#8707;</span> <span class="n">x</span><span class="o">,</span> <span class="n">f</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">y</span><span class="o">,</span> <span class="k">from</span> <span class="n">exists.intro</span> <span class="n">x</span> <span class="n">this</span>
</pre></div>
</div>
</div></div>
<div class="section" id="defining-the-inverse-classically">
<h2>16.4. Defining the Inverse Classically<a class="headerlink" href="#defining-the-inverse-classically" title="Permalink to this headline">&#182;</a></h2>
<p>All the theorems listed in the previous section are found in the Lean
library, and are available to you when you open the function namespace
with <code class="docutils literal"><span class="pre">open</span> <span class="pre">function</span></code>:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover.github.io/live/3.4.1/#code=open%20function%0A%0A#check%20comp%0A#check%20left_inverse%0A#check%20has_right_inverse" target="_blank">
try it!</a></div><div class="highlight-lean"><div class="highlight"><pre><span class="kn">open</span> <span class="n">function</span>

<span class="k">#check</span> <span class="n">comp</span>
<span class="k">#check</span> <span class="n">left_inverse</span>
<span class="k">#check</span> <span class="n">has_right_inverse</span>
</pre></div>
</div>
</div><p>Defining inverse functions, however, requires classical reasoning, which
we get by opening the classical namespace:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover.github.io/live/3.4.1/#code=open%20classical%0A%0Asection%0A%20%20variables%20A%20B%20:%20Type%0A%20%20variable%20P%20:%20A%20%E2%86%92%20Prop%0A%20%20variable%20R%20:%20A%20%E2%86%92%20B%20%E2%86%92%20Prop%0A%0A%20%20example%20:%20(%E2%88%80%20x,%20%E2%88%83%20y,%20R%20x%20y)%20%E2%86%92%20%E2%88%83%20f%20:%20A%20%E2%86%92%20B,%20%E2%88%80%20x,%20R%20x%20(f%20x)%20:=%0A%20%20axiom_of_choice%0A%0A%20%20example%20(h%20:%20%E2%88%83%20x,%20P%20x)%20:%20P%20(some%20h)%20:=%0A%20%20some_spec%20h%0Aend" target="_blank">
try it!</a></div><div class="highlight-lean"><div class="highlight"><pre><span class="kn">open</span> <span class="n">classical</span>

<span class="kn">section</span>
  <span class="kd">variables</span> <span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="kt">Type</span>
  <span class="kd">variable</span> <span class="n">P</span> <span class="o">:</span> <span class="n">A</span> <span class="bp">&#8594;</span> <span class="kt">Prop</span>
  <span class="kd">variable</span> <span class="n">R</span> <span class="o">:</span> <span class="n">A</span> <span class="bp">&#8594;</span> <span class="n">B</span> <span class="bp">&#8594;</span> <span class="kt">Prop</span>

  <span class="kd">example</span> <span class="o">:</span> <span class="o">(</span><span class="bp">&#8704;</span> <span class="n">x</span><span class="o">,</span> <span class="bp">&#8707;</span> <span class="n">y</span><span class="o">,</span> <span class="n">R</span> <span class="n">x</span> <span class="n">y</span><span class="o">)</span> <span class="bp">&#8594;</span> <span class="bp">&#8707;</span> <span class="n">f</span> <span class="o">:</span> <span class="n">A</span> <span class="bp">&#8594;</span> <span class="n">B</span><span class="o">,</span> <span class="bp">&#8704;</span> <span class="n">x</span><span class="o">,</span> <span class="n">R</span> <span class="n">x</span> <span class="o">(</span><span class="n">f</span> <span class="n">x</span><span class="o">)</span> <span class="o">:=</span>
  <span class="n">axiom_of_choice</span>

  <span class="kd">example</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">&#8707;</span> <span class="n">x</span><span class="o">,</span> <span class="n">P</span> <span class="n">x</span><span class="o">)</span> <span class="o">:</span> <span class="n">P</span> <span class="o">(</span><span class="n">some</span> <span class="n">h</span><span class="o">)</span> <span class="o">:=</span>
  <span class="n">some_spec</span> <span class="n">h</span>
<span class="kd">end</span>
</pre></div>
</div>
</div><p>The axiom of choice tells us that if, for every <code class="docutils literal"><span class="pre">x</span> <span class="pre">:</span> <span class="pre">X</span></code>, there is a <code class="docutils literal"><span class="pre">y</span> <span class="pre">:</span> <span class="pre">Y</span></code> satisfying <code class="docutils literal"><span class="pre">R</span> <span class="pre">x</span> <span class="pre">y</span></code>, then there is a function <code class="docutils literal"><span class="pre">f</span> <span class="pre">:</span> <span class="pre">X</span> <span class="pre">&#8594;</span> <span class="pre">Y</span></code> which, for every <code class="docutils literal"><span class="pre">x</span></code> chooses such a <code class="docutils literal"><span class="pre">y</span></code>. In Lean, this &#8220;axiom&#8221; is proved using a classical construction, the <code class="docutils literal"><span class="pre">some</span></code> function (sometimes called &#8220;the indefinite description operator&#8221;) which, given that there is some <code class="docutils literal"><span class="pre">x</span></code> satisfying <code class="docutils literal"><span class="pre">P</span> <span class="pre">x</span></code>, returns such an <code class="docutils literal"><span class="pre">x</span></code>. With these constructions, the inverse function is defined as follows:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover.github.io/live/3.4.1/#code=open%20classical%20function%0Alocal%20attribute%20%5Binstance%5D%20prop_decidable%0A%0Avariables%20%7BX%20Y%20:%20Type%7D%0A%0Anoncomputable%20def%20inverse%20(f%20:%20X%20%E2%86%92%20Y)%20(default%20:%20X)%20:%20Y%20%E2%86%92%20X%20:=%0A%CE%BB%20y,%20if%20h%20:%20%E2%88%83%20x,%20f%20x%20=%20y%20then%20some%20h%20else%20default" target="_blank">
try it!</a></div><div class="highlight-lean"><div class="highlight"><pre><span class="kn">open</span> <span class="n">classical</span> <span class="n">function</span>
<span class="kn">local</span> <span class="kn">attribute</span> <span class="o">[</span><span class="kd">instance</span><span class="o">]</span> <span class="n">prop_decidable</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">X</span> <span class="n">Y</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span>

<span class="kd">noncomputable</span> <span class="kd">def</span> <span class="n">inverse</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">&#8594;</span> <span class="n">Y</span><span class="o">)</span> <span class="o">(</span><span class="n">default</span> <span class="o">:</span> <span class="n">X</span><span class="o">)</span> <span class="o">:</span> <span class="n">Y</span> <span class="bp">&#8594;</span> <span class="n">X</span> <span class="o">:=</span>
<span class="bp">&#955;</span> <span class="n">y</span><span class="o">,</span> <span class="k">if</span> <span class="n">h</span> <span class="o">:</span> <span class="bp">&#8707;</span> <span class="n">x</span><span class="o">,</span> <span class="n">f</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">y</span> <span class="k">then</span> <span class="n">some</span> <span class="n">h</span> <span class="k">else</span> <span class="n">default</span>
</pre></div>
</div>
</div><p>Lean requires us to acknowledge that the definition is not computational, since, first, it may not be algorithmically possible to decide whether or not condition <code class="docutils literal"><span class="pre">H</span></code> holds, and even if it does, it may not be algorithmically possible to find a suitable value of <code class="docutils literal"><span class="pre">x</span></code>.</p>
<p>Below, the proposition <code class="docutils literal"><span class="pre">inverse_of_exists</span></code> asserts that <code class="docutils literal"><span class="pre">inverse</span></code> meets its specification, and the subsequent theorem shows that if <code class="docutils literal"><span class="pre">f</span></code> is injective, then the <code class="docutils literal"><span class="pre">inverse</span></code> function really is a left inverse.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover.github.io/live/3.4.1/#code=open%20classical%20function%0Alocal%20attribute%20%5Binstance%5D%20prop_decidable%0A%0Avariables%20%7BX%20Y%20:%20Type%7D%0A%0Anoncomputable%20def%20inverse%20(f%20:%20X%20%E2%86%92%20Y)%20(default%20:%20X)%20:%20Y%20%E2%86%92%20X%20:=%0A%CE%BB%20y,%20if%20h%20:%20%E2%88%83%20x,%20f%20x%20=%20y%20then%20some%20h%20else%20default%0A%0A--%20BEGIN%0Atheorem%20inverse_of_exists%20(f%20:%20X%20%E2%86%92%20Y)%20(default%20:%20X)%20(y%20:%20Y)%0A%20%20(h%20:%20%E2%88%83%20x,%20f%20x%20=%20y)%20:%0Af%20(inverse%20f%20default%20y)%20=%20y%20:=%0Ahave%20h1%20:%20inverse%20f%20default%20y%20=%20some%20h,%20from%20dif_pos%20h,%0Ahave%20h2%20:%20f%20(some%20h)%20=%20y,%20from%20some_spec%20h,%0Aeq.subst%20(eq.symm%20h1)%20h2%0A%0Atheorem%20is_left_inverse_of_injective%20(f%20:%20X%20%E2%86%92%20Y)%20(default%20:%20X)%0A%20%20(injf%20:%20injective%20f)%20:%0Aleft_inverse%20(inverse%20f%20default)%20f%20:=%0Alet%20finv%20:=%20(inverse%20f%20default)%20in%0Aassume%20x,%0Ahave%20h1%20:%20%E2%88%83%20x',%20f%20x'%20=%20f%20x,%20from%20exists.intro%20x%20rfl,%0Ahave%20h2%20:%20f%20(finv%20(f%20x))%20=%20f%20x,%20from%20inverse_of_exists%20f%20default%20(f%20x)%20h1,%0Ashow%20finv%20(f%20x)%20=%20x,%20from%20injf%20h2%0A--%20END" target="_blank">
try it!</a></div><div class="highlight-lean"><div class="highlight"><pre><span class="kd">theorem</span> <span class="n">inverse_of_exists</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">&#8594;</span> <span class="n">Y</span><span class="o">)</span> <span class="o">(</span><span class="n">default</span> <span class="o">:</span> <span class="n">X</span><span class="o">)</span> <span class="o">(</span><span class="n">y</span> <span class="o">:</span> <span class="n">Y</span><span class="o">)</span>
  <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">&#8707;</span> <span class="n">x</span><span class="o">,</span> <span class="n">f</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">y</span><span class="o">)</span> <span class="o">:</span>
<span class="n">f</span> <span class="o">(</span><span class="n">inverse</span> <span class="n">f</span> <span class="n">default</span> <span class="n">y</span><span class="o">)</span> <span class="bp">=</span> <span class="n">y</span> <span class="o">:=</span>
<span class="k">have</span> <span class="n">h1</span> <span class="o">:</span> <span class="n">inverse</span> <span class="n">f</span> <span class="n">default</span> <span class="n">y</span> <span class="bp">=</span> <span class="n">some</span> <span class="n">h</span><span class="o">,</span> <span class="k">from</span> <span class="n">dif_pos</span> <span class="n">h</span><span class="o">,</span>
<span class="k">have</span> <span class="n">h2</span> <span class="o">:</span> <span class="n">f</span> <span class="o">(</span><span class="n">some</span> <span class="n">h</span><span class="o">)</span> <span class="bp">=</span> <span class="n">y</span><span class="o">,</span> <span class="k">from</span> <span class="n">some_spec</span> <span class="n">h</span><span class="o">,</span>
<span class="n">eq.subst</span> <span class="o">(</span><span class="n">eq.symm</span> <span class="n">h1</span><span class="o">)</span> <span class="n">h2</span>

<span class="kd">theorem</span> <span class="n">is_left_inverse_of_injective</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">&#8594;</span> <span class="n">Y</span><span class="o">)</span> <span class="o">(</span><span class="n">default</span> <span class="o">:</span> <span class="n">X</span><span class="o">)</span>
  <span class="o">(</span><span class="n">injf</span> <span class="o">:</span> <span class="n">injective</span> <span class="n">f</span><span class="o">)</span> <span class="o">:</span>
<span class="n">left_inverse</span> <span class="o">(</span><span class="n">inverse</span> <span class="n">f</span> <span class="n">default</span><span class="o">)</span> <span class="n">f</span> <span class="o">:=</span>
<span class="k">let</span> <span class="n">finv</span> <span class="o">:=</span> <span class="o">(</span><span class="n">inverse</span> <span class="n">f</span> <span class="n">default</span><span class="o">)</span> <span class="k">in</span>
<span class="k">assume</span> <span class="n">x</span><span class="o">,</span>
<span class="k">have</span> <span class="n">h1</span> <span class="o">:</span> <span class="bp">&#8707;</span> <span class="n">x&#39;</span><span class="o">,</span> <span class="n">f</span> <span class="n">x&#39;</span> <span class="bp">=</span> <span class="n">f</span> <span class="n">x</span><span class="o">,</span> <span class="k">from</span> <span class="n">exists.intro</span> <span class="n">x</span> <span class="n">rfl</span><span class="o">,</span>
<span class="k">have</span> <span class="n">h2</span> <span class="o">:</span> <span class="n">f</span> <span class="o">(</span><span class="n">finv</span> <span class="o">(</span><span class="n">f</span> <span class="n">x</span><span class="o">))</span> <span class="bp">=</span> <span class="n">f</span> <span class="n">x</span><span class="o">,</span> <span class="k">from</span> <span class="n">inverse_of_exists</span> <span class="n">f</span> <span class="n">default</span> <span class="o">(</span><span class="n">f</span> <span class="n">x</span><span class="o">)</span> <span class="n">h1</span><span class="o">,</span>
<span class="k">show</span> <span class="n">finv</span> <span class="o">(</span><span class="n">f</span> <span class="n">x</span><span class="o">)</span> <span class="bp">=</span> <span class="n">x</span><span class="o">,</span> <span class="k">from</span> <span class="n">injf</span> <span class="n">h2</span>
</pre></div>
</div>
</div></div>
<div class="section" id="functions-and-sets-in-lean">
<h2>16.5. Functions and Sets in Lean<a class="headerlink" href="#functions-and-sets-in-lean" title="Permalink to this headline">&#182;</a></h2>
<p>In <a class="reference internal" href="first_order_logic.html#relativization-and-sorts"><span class="std std-numref">Section 7.4</span></a> we saw how to represent relativized universal and existential quantifiers when formalizing phrases like &#8220;every prime number greater than two is odd&#8221; and &#8220;some prime number is even.&#8221; In a similar way, we can relativize statements to sets. In symbolic logic, the expression <span class="math">\(\exists x \in A \; P (x)\)</span> abbreviates <span class="math">\(\exists x \; (x \in A \wedge P(x))\)</span>, and <span class="math">\(\forall x \in A \; P (x)\)</span> abbreviates <span class="math">\(\forall x \; (x \in A \to P(x))\)</span>.</p>
<p>Lean also defines notation for relativized quantifiers:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover.github.io/live/3.4.1/#code=variables%20(X%20:%20Type)%20(A%20:%20set%20X)%20(P%20:%20X%20%E2%86%92%20Prop)%0A%0A#check%20%E2%88%80%20x%20%E2%88%88%20A,%20P%20x%0A#check%20%E2%88%83%20x%20%E2%88%88%20A,%20P%20x" target="_blank">
try it!</a></div><div class="highlight-lean"><div class="highlight"><pre><span class="kd">variables</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">set</span> <span class="n">X</span><span class="o">)</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">&#8594;</span> <span class="kt">Prop</span><span class="o">)</span>

<span class="k">#check</span> <span class="bp">&#8704;</span> <span class="n">x</span> <span class="bp">&#8712;</span> <span class="n">A</span><span class="o">,</span> <span class="n">P</span> <span class="n">x</span>
<span class="k">#check</span> <span class="bp">&#8707;</span> <span class="n">x</span> <span class="bp">&#8712;</span> <span class="n">A</span><span class="o">,</span> <span class="n">P</span> <span class="n">x</span>
</pre></div>
</div>
</div><p>Here is an example of how to use the bounded universal quantifier:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover.github.io/live/3.4.1/#code=variables%20(X%20:%20Type)%20(A%20:%20set%20X)%20(P%20:%20X%20%E2%86%92%20Prop)%0A%0A--%20BEGIN%0Aexample%20(h%20:%20%E2%88%80%20x%20%E2%88%88%20A,%20P%20x)%20(x%20:%20X)%20(h1%20:%20x%20%E2%88%88%20A)%20:%20P%20x%20:=%20h%20x%20h1%0A--%20END" target="_blank">
try it!</a></div><div class="highlight-lean"><div class="highlight"><pre><span class="kd">example</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">&#8704;</span> <span class="n">x</span> <span class="bp">&#8712;</span> <span class="n">A</span><span class="o">,</span> <span class="n">P</span> <span class="n">x</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">X</span><span class="o">)</span> <span class="o">(</span><span class="n">h1</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">&#8712;</span> <span class="n">A</span><span class="o">)</span> <span class="o">:</span> <span class="n">P</span> <span class="n">x</span> <span class="o">:=</span> <span class="n">h</span> <span class="n">x</span> <span class="n">h1</span>
</pre></div>
</div>
</div><p>Using bounded quantifiers, we can talk about the behavior of functions on particular sets:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover.github.io/live/3.4.1/#code=import%20data.set%0Aopen%20set%20function%0A%0Avariables%20%7BX%20Y%20:%20Type%7D%0Avariables%20(A%20%20:%20set%20X)%20(B%20:%20set%20Y)%0A%0Adef%20maps_to%20(f%20:%20X%20%E2%86%92%20Y)%20(A%20:%20set%20X)%20(B%20:%20set%20Y)%20:=%20%E2%88%80%20x%20%E2%88%88%20A,%20f%20x%20%E2%88%88%20B%0A%0Adef%20inj_on%20(f%20:%20X%20%E2%86%92%20Y)%20(A%20:%20set%20X)%20:=%20%E2%88%80%20(x%E2%82%81%20%E2%88%88%20A)%20(x%E2%82%82%20%E2%88%88%20A),%20f%20x%E2%82%81%20=%20f%20x%E2%82%82%20%E2%86%92%20x%E2%82%81%20=%20x%E2%82%82%0A%0Adef%20surj_on%20(f%20:%20X%20%E2%86%92%20Y)%20(A%20:%20set%20X)%20(B%20:%20set%20Y)%20:=%20B%20%E2%8A%86%20f%20''%20A" target="_blank">
try it!</a></div><div class="highlight-lean"><div class="highlight"><pre><span class="kn">import</span> <span class="n">data.set</span>
<span class="kn">open</span> <span class="n">set</span> <span class="n">function</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">X</span> <span class="n">Y</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span>
<span class="kd">variables</span> <span class="o">(</span><span class="n">A</span>  <span class="o">:</span> <span class="n">set</span> <span class="n">X</span><span class="o">)</span> <span class="o">(</span><span class="n">B</span> <span class="o">:</span> <span class="n">set</span> <span class="n">Y</span><span class="o">)</span>

<span class="kd">def</span> <span class="n">maps_to</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">&#8594;</span> <span class="n">Y</span><span class="o">)</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">set</span> <span class="n">X</span><span class="o">)</span> <span class="o">(</span><span class="n">B</span> <span class="o">:</span> <span class="n">set</span> <span class="n">Y</span><span class="o">)</span> <span class="o">:=</span> <span class="bp">&#8704;</span> <span class="n">x</span> <span class="bp">&#8712;</span> <span class="n">A</span><span class="o">,</span> <span class="n">f</span> <span class="n">x</span> <span class="bp">&#8712;</span> <span class="n">B</span>

<span class="kd">def</span> <span class="n">inj_on</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">&#8594;</span> <span class="n">Y</span><span class="o">)</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">set</span> <span class="n">X</span><span class="o">)</span> <span class="o">:=</span> <span class="bp">&#8704;</span> <span class="o">(</span><span class="n">x&#8321;</span> <span class="bp">&#8712;</span> <span class="n">A</span><span class="o">)</span> <span class="o">(</span><span class="n">x&#8322;</span> <span class="bp">&#8712;</span> <span class="n">A</span><span class="o">),</span> <span class="n">f</span> <span class="n">x&#8321;</span> <span class="bp">=</span> <span class="n">f</span> <span class="n">x&#8322;</span> <span class="bp">&#8594;</span> <span class="n">x&#8321;</span> <span class="bp">=</span> <span class="n">x&#8322;</span>

<span class="kd">def</span> <span class="n">surj_on</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">&#8594;</span> <span class="n">Y</span><span class="o">)</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">set</span> <span class="n">X</span><span class="o">)</span> <span class="o">(</span><span class="n">B</span> <span class="o">:</span> <span class="n">set</span> <span class="n">Y</span><span class="o">)</span> <span class="o">:=</span> <span class="n">B</span> <span class="bp">&#8838;</span> <span class="n">f</span> <span class="bp">&#39;&#39;</span> <span class="n">A</span>
</pre></div>
</div>
</div><p>The expression <code class="docutils literal"><span class="pre">maps_to</span> <span class="pre">f</span> <span class="pre">A</span> <span class="pre">B</span></code> asserts that <code class="docutils literal"><span class="pre">f</span></code> maps elements of the set <code class="docutils literal"><span class="pre">A</span></code> to the set <code class="docutils literal"><span class="pre">B</span></code>, and the expression <code class="docutils literal"><span class="pre">inj_on</span> <span class="pre">f</span> <span class="pre">A</span></code> asserts that <code class="docutils literal"><span class="pre">f</span></code> is injective on <code class="docutils literal"><span class="pre">A</span></code>. The expression <code class="docutils literal"><span class="pre">surj_on</span> <span class="pre">f</span> <span class="pre">A</span> <span class="pre">B</span></code> asserts that, viewed as a function defined on elements of <code class="docutils literal"><span class="pre">A</span></code>, the function <code class="docutils literal"><span class="pre">f</span></code> is surjective onto the set <code class="docutils literal"><span class="pre">B</span></code>. Here are examples of how they can be used:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover.github.io/live/3.4.1/#code=import%20data.set%0Aopen%20set%20function%0A%0Avariables%20%7BX%20Y%20:%20Type%7D%0A%0Adef%20maps_to%20(f%20:%20X%20%E2%86%92%20Y)%20(A%20:%20set%20X)%20(B%20:%20set%20Y)%20:=%20%E2%88%80%20x%20%E2%88%88%20A,%20f%20x%20%E2%88%88%20B%0Adef%20inj_on%20(f%20:%20X%20%E2%86%92%20Y)%20(A%20:%20set%20X)%20:=%20%E2%88%80%20(x%E2%82%81%20%E2%88%88%20A)%20(x%E2%82%82%20%E2%88%88%20A),%20f%20x%E2%82%81%20=%20f%20x%E2%82%82%20%E2%86%92%20x%E2%82%81%20=%20x%E2%82%82%0Adef%20surj_on%20(f%20:%20X%20%E2%86%92%20Y)%20(A%20:%20set%20X)%20(B%20:%20set%20Y)%20:=%20B%20%E2%8A%86%20f%20''%20A%0A%0A--%20BEGIN%0Avariables%20(f%20:%20X%20%E2%86%92%20Y)%20(A%20:%20set%20X)%20(B%20:%20set%20Y)%0A%0Aexample%20(h%20:%20maps_to%20f%20A%20B)%20(x%20:%20X)%20(h1%20:%20x%20%E2%88%88%20A)%20:%20f%20x%20%E2%88%88%20B%20:=%20h%20x%20h1%0A%0Aexample%20(h%20:%20inj_on%20f%20A)%20(x%E2%82%81%20x%E2%82%82%20:%20X)%20(h1%20:%20x%E2%82%81%20%E2%88%88%20A)%20(h2%20:%20x%E2%82%82%20%E2%88%88%20A)%0A%20%20%20%20(h3%20:%20f%20x%E2%82%81%20=%20f%20x%E2%82%82)%20:%20x%E2%82%81%20=%20x%E2%82%82%20:=%0Ah%20x%E2%82%81%20h1%20x%E2%82%82%20h2%20h3%0A%0Aexample%20(h%20:%20surj_on%20f%20A%20B)%20(y%20:%20Y)%20(h1%20:%20y%20%E2%88%88%20B)%20:%20%E2%88%83%20x,%20x%20%E2%88%88%20A%20%E2%88%A7%20f%20x%20=%20y%20:=%0Ah%20h1%0A--%20END" target="_blank">
try it!</a></div><div class="highlight-lean"><div class="highlight"><pre><span class="kd">variables</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">&#8594;</span> <span class="n">Y</span><span class="o">)</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">set</span> <span class="n">X</span><span class="o">)</span> <span class="o">(</span><span class="n">B</span> <span class="o">:</span> <span class="n">set</span> <span class="n">Y</span><span class="o">)</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">maps_to</span> <span class="n">f</span> <span class="n">A</span> <span class="n">B</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">X</span><span class="o">)</span> <span class="o">(</span><span class="n">h1</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">&#8712;</span> <span class="n">A</span><span class="o">)</span> <span class="o">:</span> <span class="n">f</span> <span class="n">x</span> <span class="bp">&#8712;</span> <span class="n">B</span> <span class="o">:=</span> <span class="n">h</span> <span class="n">x</span> <span class="n">h1</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">inj_on</span> <span class="n">f</span> <span class="n">A</span><span class="o">)</span> <span class="o">(</span><span class="n">x&#8321;</span> <span class="n">x&#8322;</span> <span class="o">:</span> <span class="n">X</span><span class="o">)</span> <span class="o">(</span><span class="n">h1</span> <span class="o">:</span> <span class="n">x&#8321;</span> <span class="bp">&#8712;</span> <span class="n">A</span><span class="o">)</span> <span class="o">(</span><span class="n">h2</span> <span class="o">:</span> <span class="n">x&#8322;</span> <span class="bp">&#8712;</span> <span class="n">A</span><span class="o">)</span>
    <span class="o">(</span><span class="n">h3</span> <span class="o">:</span> <span class="n">f</span> <span class="n">x&#8321;</span> <span class="bp">=</span> <span class="n">f</span> <span class="n">x&#8322;</span><span class="o">)</span> <span class="o">:</span> <span class="n">x&#8321;</span> <span class="bp">=</span> <span class="n">x&#8322;</span> <span class="o">:=</span>
<span class="n">h</span> <span class="n">x&#8321;</span> <span class="n">h1</span> <span class="n">x&#8322;</span> <span class="n">h2</span> <span class="n">h3</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">surj_on</span> <span class="n">f</span> <span class="n">A</span> <span class="n">B</span><span class="o">)</span> <span class="o">(</span><span class="n">y</span> <span class="o">:</span> <span class="n">Y</span><span class="o">)</span> <span class="o">(</span><span class="n">h1</span> <span class="o">:</span> <span class="n">y</span> <span class="bp">&#8712;</span> <span class="n">B</span><span class="o">)</span> <span class="o">:</span> <span class="bp">&#8707;</span> <span class="n">x</span><span class="o">,</span> <span class="n">x</span> <span class="bp">&#8712;</span> <span class="n">A</span> <span class="bp">&#8743;</span> <span class="n">f</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">y</span> <span class="o">:=</span>
<span class="n">h</span> <span class="n">h1</span>
</pre></div>
</div>
</div><p>Actually, it is slightly more convenient to mark the variables in <code class="docutils literal"><span class="pre">maps_to</span></code> and <code class="docutils literal"><span class="pre">inj_on</span></code> as implicit:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover.github.io/live/3.4.1/#code=import%20data.set%0Aopen%20set%20function%0A%0Avariables%20%7BX%20Y%20:%20Type%7D%0A%0A--%20BEGIN%0Adef%20maps_to%20(f%20:%20X%20%E2%86%92%20Y)%20(A%20:%20set%20X)%20(B%20:%20set%20Y)%20:=%20%E2%88%80%20%7Bx%7D,%20x%20%E2%88%88%20A%20%E2%86%92%20f%20x%20%E2%88%88%20B%0A%0Adef%20inj_on%20(f%20:%20X%20%E2%86%92%20Y)%20(A%20:%20set%20X)%20:=%20%E2%88%80%20%7Bx%E2%82%81%20x%E2%82%82%7D,%20x%E2%82%81%20%E2%88%88%20A%20%E2%86%92%20x%E2%82%82%20%E2%88%88%20A%20%E2%86%92%20f%20x%E2%82%81%20=%20f%20x%E2%82%82%20%E2%86%92%20x%E2%82%81%20=%20x%E2%82%82%0A--%20END" target="_blank">
try it!</a></div><div class="highlight-lean"><div class="highlight"><pre><span class="kd">def</span> <span class="n">maps_to</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">&#8594;</span> <span class="n">Y</span><span class="o">)</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">set</span> <span class="n">X</span><span class="o">)</span> <span class="o">(</span><span class="n">B</span> <span class="o">:</span> <span class="n">set</span> <span class="n">Y</span><span class="o">)</span> <span class="o">:=</span> <span class="bp">&#8704;</span> <span class="o">{</span><span class="n">x</span><span class="o">},</span> <span class="n">x</span> <span class="bp">&#8712;</span> <span class="n">A</span> <span class="bp">&#8594;</span> <span class="n">f</span> <span class="n">x</span> <span class="bp">&#8712;</span> <span class="n">B</span>

<span class="kd">def</span> <span class="n">inj_on</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">&#8594;</span> <span class="n">Y</span><span class="o">)</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">set</span> <span class="n">X</span><span class="o">)</span> <span class="o">:=</span> <span class="bp">&#8704;</span> <span class="o">{</span><span class="n">x&#8321;</span> <span class="n">x&#8322;</span><span class="o">},</span> <span class="n">x&#8321;</span> <span class="bp">&#8712;</span> <span class="n">A</span> <span class="bp">&#8594;</span> <span class="n">x&#8322;</span> <span class="bp">&#8712;</span> <span class="n">A</span> <span class="bp">&#8594;</span> <span class="n">f</span> <span class="n">x&#8321;</span> <span class="bp">=</span> <span class="n">f</span> <span class="n">x&#8322;</span> <span class="bp">&#8594;</span> <span class="n">x&#8321;</span> <span class="bp">=</span> <span class="n">x&#8322;</span>
</pre></div>
</div>
</div><p>In that case, we can leave out some arguments:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover.github.io/live/3.4.1/#code=import%20data.set%0Aopen%20set%20function%0A%0Avariables%20%7BX%20Y%20:%20Type%7D%0A%0Adef%20maps_to%20(f%20:%20X%20%E2%86%92%20Y)%20(A%20:%20set%20X)%20(B%20:%20set%20Y)%20:=%20%E2%88%80%20%7Bx%7D,%20x%20%E2%88%88%20A%20%E2%86%92%20f%20x%20%E2%88%88%20B%0Adef%20inj_on%20(f%20:%20X%20%E2%86%92%20Y)%20(A%20:%20set%20X)%20:=%20%E2%88%80%20%7Bx%E2%82%81%20x%E2%82%82%7D,%20x%E2%82%81%20%E2%88%88%20A%20%E2%86%92%20x%E2%82%82%20%E2%88%88%20A%20%E2%86%92%20f%20x%E2%82%81%20=%20f%20x%E2%82%82%20%E2%86%92%20x%E2%82%81%20=%20x%E2%82%82%0Adef%20surj_on%20(f%20:%20X%20%E2%86%92%20Y)%20(A%20:%20set%20X)%20(B%20:%20set%20Y)%20:=%20B%20%E2%8A%86%20f%20''%20A%0A%0A--%20BEGIN%0Avariables%20(f%20:%20X%20%E2%86%92%20Y)%20(A%20:%20set%20X)%20(B%20:%20set%20Y)%0A%0Aexample%20(h%20:%20maps_to%20f%20A%20B)%20(x%20:%20X)%20(h1%20:%20x%20%E2%88%88%20A)%20:%20f%20x%20%E2%88%88%20B%20:=%20h%20h1%0A%0Aexample%20(h%20:%20inj_on%20f%20A)%20(x%E2%82%81%20x%E2%82%82%20:%20X)%20(h1%20:%20x%E2%82%81%20%E2%88%88%20A)%20(h2%20:%20x%E2%82%82%20%E2%88%88%20A)%0A%20%20%20%20(h3%20:%20f%20x%E2%82%81%20=%20f%20x%E2%82%82)%20:%20x%E2%82%81%20=%20x%E2%82%82%20:=%0Ah%20h1%20h2%20h3%0A--%20END" target="_blank">
try it!</a></div><div class="highlight-lean"><div class="highlight"><pre><span class="kd">variables</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">&#8594;</span> <span class="n">Y</span><span class="o">)</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">set</span> <span class="n">X</span><span class="o">)</span> <span class="o">(</span><span class="n">B</span> <span class="o">:</span> <span class="n">set</span> <span class="n">Y</span><span class="o">)</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">maps_to</span> <span class="n">f</span> <span class="n">A</span> <span class="n">B</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">X</span><span class="o">)</span> <span class="o">(</span><span class="n">h1</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">&#8712;</span> <span class="n">A</span><span class="o">)</span> <span class="o">:</span> <span class="n">f</span> <span class="n">x</span> <span class="bp">&#8712;</span> <span class="n">B</span> <span class="o">:=</span> <span class="n">h</span> <span class="n">h1</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">inj_on</span> <span class="n">f</span> <span class="n">A</span><span class="o">)</span> <span class="o">(</span><span class="n">x&#8321;</span> <span class="n">x&#8322;</span> <span class="o">:</span> <span class="n">X</span><span class="o">)</span> <span class="o">(</span><span class="n">h1</span> <span class="o">:</span> <span class="n">x&#8321;</span> <span class="bp">&#8712;</span> <span class="n">A</span><span class="o">)</span> <span class="o">(</span><span class="n">h2</span> <span class="o">:</span> <span class="n">x&#8322;</span> <span class="bp">&#8712;</span> <span class="n">A</span><span class="o">)</span>
    <span class="o">(</span><span class="n">h3</span> <span class="o">:</span> <span class="n">f</span> <span class="n">x&#8321;</span> <span class="bp">=</span> <span class="n">f</span> <span class="n">x&#8322;</span><span class="o">)</span> <span class="o">:</span> <span class="n">x&#8321;</span> <span class="bp">=</span> <span class="n">x&#8322;</span> <span class="o">:=</span>
<span class="n">h</span> <span class="n">h1</span> <span class="n">h2</span> <span class="n">h3</span>
</pre></div>
</div>
</div><p>In the examples below, we&#8217;ll use the versions with implicit arguments. The expression <code class="docutils literal"><span class="pre">surj_on</span> <span class="pre">f</span> <span class="pre">A</span> <span class="pre">B</span></code> asserts that, viewed as a function defined on elements of <code class="docutils literal"><span class="pre">A</span></code>, the function <code class="docutils literal"><span class="pre">f</span></code> is surjective onto the set <code class="docutils literal"><span class="pre">B</span></code>.</p>
<p>With these notions in hand, we can prove that the composition of injective functions is injective. The proof is similar to the one above, though now we have to be more careful to relativize claims to <code class="docutils literal"><span class="pre">A</span></code> and <code class="docutils literal"><span class="pre">B</span></code>:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover.github.io/live/3.4.1/#code=import%20data.set%0Aopen%20set%20function%0A%0Avariables%20%7BX%20Y%20Z%20:%20Type%7D%0A%0Adef%20maps_to%20(f%20:%20X%20%E2%86%92%20Y)%20(A%20:%20set%20X)%20(B%20:%20set%20Y)%20:=%20%E2%88%80%20%7Bx%7D,%20x%20%E2%88%88%20A%20%E2%86%92%20f%20x%20%E2%88%88%20B%0Adef%20inj_on%20(f%20:%20X%20%E2%86%92%20Y)%20(A%20:%20set%20X)%20:=%20%E2%88%80%20%7Bx%E2%82%81%20x%E2%82%82%7D,%20x%E2%82%81%20%E2%88%88%20A%20%E2%86%92%20x%E2%82%82%20%E2%88%88%20A%20%E2%86%92%20f%20x%E2%82%81%20=%20f%20x%E2%82%82%20%E2%86%92%20x%E2%82%81%20=%20x%E2%82%82%0Adef%20surj_on%20(f%20:%20X%20%E2%86%92%20Y)%20(A%20:%20set%20X)%20(B%20:%20set%20Y)%20:=%20B%20%E2%8A%86%20f%20''%20A%0A%0Avariables%20(A%20:%20set%20X)%20(B%20:%20set%20Y)%0Avariables%20(f%20:%20X%20%E2%86%92%20Y)%20(g%20:%20Y%20%E2%86%92%20Z)%0A%0A--%20BEGIN%0Atheorem%20inj_on_comp%20(fAB%20:%20maps_to%20f%20A%20B)%20(hg%20:%20inj_on%20g%20B)%20(hf:%20inj_on%20f%20A)%20:%0A%20%20inj_on%20(g%20%E2%88%98%20f)%20A%20:=%0Aassume%20x1%20x2%20:%20X,%0Aassume%20x1A%20:%20x1%20%E2%88%88%20A,%0Aassume%20x2A%20:%20x2%20%E2%88%88%20A,%0Ahave%20fx1B%20:%20f%20x1%20%E2%88%88%20B,%20from%20fAB%20x1A,%0Ahave%20fx2B%20:%20f%20x2%20%E2%88%88%20B,%20from%20fAB%20x2A,%0Aassume%20h1%20:%20g%20(f%20x1)%20=%20g%20(f%20x2),%0Ahave%20h2%20:%20f%20x1%20=%20f%20x2,%20from%20hg%20fx1B%20fx2B%20h1,%0Ashow%20x1%20=%20x2,%20from%20hf%20x1A%20x2A%20h2%0A--%20END" target="_blank">
try it!</a></div><div class="highlight-lean"><div class="highlight"><pre><span class="kd">theorem</span> <span class="n">inj_on_comp</span> <span class="o">(</span><span class="n">fAB</span> <span class="o">:</span> <span class="n">maps_to</span> <span class="n">f</span> <span class="n">A</span> <span class="n">B</span><span class="o">)</span> <span class="o">(</span><span class="n">hg</span> <span class="o">:</span> <span class="n">inj_on</span> <span class="n">g</span> <span class="n">B</span><span class="o">)</span> <span class="o">(</span><span class="n">hf</span><span class="o">:</span> <span class="n">inj_on</span> <span class="n">f</span> <span class="n">A</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">inj_on</span> <span class="o">(</span><span class="n">g</span> <span class="bp">&#8728;</span> <span class="n">f</span><span class="o">)</span> <span class="n">A</span> <span class="o">:=</span>
<span class="k">assume</span> <span class="n">x1</span> <span class="n">x2</span> <span class="o">:</span> <span class="n">X</span><span class="o">,</span>
<span class="k">assume</span> <span class="n">x1A</span> <span class="o">:</span> <span class="n">x1</span> <span class="bp">&#8712;</span> <span class="n">A</span><span class="o">,</span>
<span class="k">assume</span> <span class="n">x2A</span> <span class="o">:</span> <span class="n">x2</span> <span class="bp">&#8712;</span> <span class="n">A</span><span class="o">,</span>
<span class="k">have</span> <span class="n">fx1B</span> <span class="o">:</span> <span class="n">f</span> <span class="n">x1</span> <span class="bp">&#8712;</span> <span class="n">B</span><span class="o">,</span> <span class="k">from</span> <span class="n">fAB</span> <span class="n">x1A</span><span class="o">,</span>
<span class="k">have</span> <span class="n">fx2B</span> <span class="o">:</span> <span class="n">f</span> <span class="n">x2</span> <span class="bp">&#8712;</span> <span class="n">B</span><span class="o">,</span> <span class="k">from</span> <span class="n">fAB</span> <span class="n">x2A</span><span class="o">,</span>
<span class="k">assume</span> <span class="n">h1</span> <span class="o">:</span> <span class="n">g</span> <span class="o">(</span><span class="n">f</span> <span class="n">x1</span><span class="o">)</span> <span class="bp">=</span> <span class="n">g</span> <span class="o">(</span><span class="n">f</span> <span class="n">x2</span><span class="o">),</span>
<span class="k">have</span> <span class="n">h2</span> <span class="o">:</span> <span class="n">f</span> <span class="n">x1</span> <span class="bp">=</span> <span class="n">f</span> <span class="n">x2</span><span class="o">,</span> <span class="k">from</span> <span class="n">hg</span> <span class="n">fx1B</span> <span class="n">fx2B</span> <span class="n">h1</span><span class="o">,</span>
<span class="k">show</span> <span class="n">x1</span> <span class="bp">=</span> <span class="n">x2</span><span class="o">,</span> <span class="k">from</span> <span class="n">hf</span> <span class="n">x1A</span> <span class="n">x2A</span> <span class="n">h2</span>
</pre></div>
</div>
</div><p>We can similarly prove that the composition of surjective functions is surjective:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover.github.io/live/3.4.1/#code=import%20data.set%0Aopen%20set%20function%0A%0Avariables%20%7BX%20Y%20Z%20:%20Type%7D%0A%0Adef%20maps_to%20(f%20:%20X%20%E2%86%92%20Y)%20(A%20:%20set%20X)%20(B%20:%20set%20Y)%20:=%20%E2%88%80%20%7Bx%7D,%20x%20%E2%88%88%20A%20%E2%86%92%20f%20x%20%E2%88%88%20B%0Adef%20inj_on%20(f%20:%20X%20%E2%86%92%20Y)%20(A%20:%20set%20X)%20:=%20%E2%88%80%20%7Bx%E2%82%81%20x%E2%82%82%7D,%20x%E2%82%81%20%E2%88%88%20A%20%E2%86%92%20x%E2%82%82%20%E2%88%88%20A%20%E2%86%92%20f%20x%E2%82%81%20=%20f%20x%E2%82%82%20%E2%86%92%20x%E2%82%81%20=%20x%E2%82%82%0Adef%20surj_on%20(f%20:%20X%20%E2%86%92%20Y)%20(A%20:%20set%20X)%20(B%20:%20set%20Y)%20:=%20B%20%E2%8A%86%20f%20''%20A%0A%0Avariables%20(A%20:%20set%20X)%20(B%20:%20set%20Y)%20(C%20:%20set%20Z)%0Avariables%20(f%20:%20X%20%E2%86%92%20Y)%20(g%20:%20Y%20%E2%86%92%20Z)%0A%0A--%20BEGIN%0Atheorem%20surj_on_comp%20(hg%20:%20surj_on%20g%20B%20C)%20(hf:%20surj_on%20f%20A%20B)%20:%0A%20%20surj_on%20(g%20%E2%88%98%20f)%20A%20C%20:=%0Aassume%20z,%0Aassume%20zc%20:%20z%20%E2%88%88%20C,%0Aexists.elim%20(hg%20zc)%20$%0Aassume%20y%20(h1%20:%20y%20%E2%88%88%20B%20%E2%88%A7%20g%20y%20=%20z),%0Aexists.elim%20(hf%20(and.left%20h1))%20$%0Aassume%20x%20(h2%20:%20x%20%E2%88%88%20A%20%E2%88%A7%20f%20x%20=%20y),%0Ashow%20%E2%88%83x,%20x%20%E2%88%88%20A%20%E2%88%A7%20g%20(f%20x)%20=%20z,%20from%0A%20%20exists.intro%20x%0A%20%20%20%20(and.intro%0A%20%20%20%20%20%20(and.left%20h2)%0A%20%20%20%20%20%20(calc%0A%20%20%20%20%20%20%20%20g%20(f%20x)%20=%20g%20y%20:%20by%20rw%20and.right%20h2%0A%20%20%20%20%20%20%20%20%20%20%20%20...%20=%20z%20%20%20:%20by%20rw%20and.right%20h1))%0A--%20END" target="_blank">
try it!</a></div><div class="highlight-lean"><div class="highlight"><pre><span class="kd">theorem</span> <span class="n">surj_on_comp</span> <span class="o">(</span><span class="n">hg</span> <span class="o">:</span> <span class="n">surj_on</span> <span class="n">g</span> <span class="n">B</span> <span class="n">C</span><span class="o">)</span> <span class="o">(</span><span class="n">hf</span><span class="o">:</span> <span class="n">surj_on</span> <span class="n">f</span> <span class="n">A</span> <span class="n">B</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">surj_on</span> <span class="o">(</span><span class="n">g</span> <span class="bp">&#8728;</span> <span class="n">f</span><span class="o">)</span> <span class="n">A</span> <span class="n">C</span> <span class="o">:=</span>
<span class="k">assume</span> <span class="n">z</span><span class="o">,</span>
<span class="k">assume</span> <span class="n">zc</span> <span class="o">:</span> <span class="n">z</span> <span class="bp">&#8712;</span> <span class="n">C</span><span class="o">,</span>
<span class="n">exists.elim</span> <span class="o">(</span><span class="n">hg</span> <span class="n">zc</span><span class="o">)</span> <span class="bp">$</span>
<span class="k">assume</span> <span class="n">y</span> <span class="o">(</span><span class="n">h1</span> <span class="o">:</span> <span class="n">y</span> <span class="bp">&#8712;</span> <span class="n">B</span> <span class="bp">&#8743;</span> <span class="n">g</span> <span class="n">y</span> <span class="bp">=</span> <span class="n">z</span><span class="o">),</span>
<span class="n">exists.elim</span> <span class="o">(</span><span class="n">hf</span> <span class="o">(</span><span class="n">and.left</span> <span class="n">h1</span><span class="o">))</span> <span class="bp">$</span>
<span class="k">assume</span> <span class="n">x</span> <span class="o">(</span><span class="n">h2</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">&#8712;</span> <span class="n">A</span> <span class="bp">&#8743;</span> <span class="n">f</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">y</span><span class="o">),</span>
<span class="k">show</span> <span class="bp">&#8707;</span><span class="n">x</span><span class="o">,</span> <span class="n">x</span> <span class="bp">&#8712;</span> <span class="n">A</span> <span class="bp">&#8743;</span> <span class="n">g</span> <span class="o">(</span><span class="n">f</span> <span class="n">x</span><span class="o">)</span> <span class="bp">=</span> <span class="n">z</span><span class="o">,</span> <span class="k">from</span>
  <span class="n">exists.intro</span> <span class="n">x</span>
    <span class="o">(</span><span class="n">and.intro</span>
      <span class="o">(</span><span class="n">and.left</span> <span class="n">h2</span><span class="o">)</span>
      <span class="o">(</span><span class="k">calc</span>
        <span class="n">g</span> <span class="o">(</span><span class="n">f</span> <span class="n">x</span><span class="o">)</span> <span class="bp">=</span> <span class="n">g</span> <span class="n">y</span> <span class="o">:</span> <span class="kd">by</span> <span class="n">rw</span> <span class="n">and.right</span> <span class="n">h2</span>
            <span class="bp">...</span> <span class="bp">=</span> <span class="n">z</span>   <span class="o">:</span> <span class="kd">by</span> <span class="n">rw</span> <span class="n">and.right</span> <span class="n">h1</span><span class="o">))</span>
</pre></div>
</div>
</div><p>The following shows that the image of a union is the union of images:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover.github.io/live/3.4.1/#code=import%20data.set%0Aopen%20set%20function%0A%0Avariables%20%7BX%20Y%20:%20Type%7D%0A%0Avariables%20(A%E2%82%81%20A%E2%82%82%20:%20set%20X)%0Avariable%20(f%20:%20X%20%E2%86%92%20Y)%0A%0A--%20BEGIN%0Atheorem%20image_union%20:%20f%20''%20(A%E2%82%81%20%E2%88%AA%20A%E2%82%82)%20=f%20''%20A%E2%82%81%20%E2%88%AA%20f%20''%20A%E2%82%82%20:=%0Aext%20(assume%20y,%20iff.intro%0A%20%20(assume%20h%20:%20y%20%E2%88%88%20image%20f%20(A%E2%82%81%20%E2%88%AA%20A%E2%82%82),%0A%20%20%20%20exists.elim%20h%20$%0A%20%20%20%20assume%20x%20h1,%0A%20%20%20%20have%20xA%E2%82%81A%E2%82%82%20:%20x%20%E2%88%88%20A%E2%82%81%20%E2%88%AA%20A%E2%82%82,%20from%20h1.left,%0A%20%20%20%20have%20fxy%20:%20f%20x%20=%20y,%20from%20h1.right,%0A%20%20%20%20or.elim%20xA%E2%82%81A%E2%82%82%0A%20%20%20%20%20%20(assume%20xA%E2%82%81,%20or.inl%20%E2%9F%A8x,%20xA%E2%82%81,%20fxy%E2%9F%A9)%0A%20%20%20%20%20%20(assume%20xA%E2%82%82,%20or.inr%20%E2%9F%A8x,%20xA%E2%82%82,%20fxy%E2%9F%A9))%0A%20%20(assume%20h%20:%20y%20%E2%88%88%20image%20f%20A%E2%82%81%20%E2%88%AA%20image%20f%20A%E2%82%82,%0A%20%20%20%20or.elim%20h%0A%20%20%20%20%20%20(assume%20yifA%E2%82%81%20:%20y%20%E2%88%88%20image%20f%20A%E2%82%81,%0A%20%20%20%20%20%20%20%20exists.elim%20yifA%E2%82%81%20$%0A%20%20%20%20%20%20%20%20assume%20x%20h1,%0A%20%20%20%20%20%20%20%20have%20xA%E2%82%81%20:%20x%20%E2%88%88%20A%E2%82%81,%20from%20h1.left,%0A%20%20%20%20%20%20%20%20have%20fxy%20:%20f%20x%20=%20y,%20from%20h1.right,%0A%20%20%20%20%20%20%20%20%E2%9F%A8x,%20or.inl%20xA%E2%82%81,%20fxy%E2%9F%A9)%0A%20%20%20%20%20%20(assume%20yifA%E2%82%82%20:%20y%20%E2%88%88%20image%20f%20A%E2%82%82,%0A%20%20%20%20%20%20%20%20exists.elim%20yifA%E2%82%82%20$%0A%20%20%20%20%20%20%20%20assume%20x%20h1,%0A%20%20%20%20%20%20%20%20have%20xA%E2%82%82%20:%20x%20%E2%88%88%20A%E2%82%82,%20from%20h1.left,%0A%20%20%20%20%20%20%20%20have%20fxy%20:%20f%20x%20=%20y,%20from%20h1.right,%0A%20%20%20%20%20%20%20%20%E2%9F%A8x,%20(or.inr%20xA%E2%82%82),%20fxy%E2%9F%A9)))%0A--%20END" target="_blank">
try it!</a></div><div class="highlight-lean"><div class="highlight"><pre><span class="kd">theorem</span> <span class="n">image_union</span> <span class="o">:</span> <span class="n">f</span> <span class="bp">&#39;&#39;</span> <span class="o">(</span><span class="n">A&#8321;</span> <span class="bp">&#8746;</span> <span class="n">A&#8322;</span><span class="o">)</span> <span class="bp">=</span><span class="n">f</span> <span class="bp">&#39;&#39;</span> <span class="n">A&#8321;</span> <span class="bp">&#8746;</span> <span class="n">f</span> <span class="bp">&#39;&#39;</span> <span class="n">A&#8322;</span> <span class="o">:=</span>
<span class="n">ext</span> <span class="o">(</span><span class="k">assume</span> <span class="n">y</span><span class="o">,</span> <span class="n">iff.intro</span>
  <span class="o">(</span><span class="k">assume</span> <span class="n">h</span> <span class="o">:</span> <span class="n">y</span> <span class="bp">&#8712;</span> <span class="n">image</span> <span class="n">f</span> <span class="o">(</span><span class="n">A&#8321;</span> <span class="bp">&#8746;</span> <span class="n">A&#8322;</span><span class="o">),</span>
    <span class="n">exists.elim</span> <span class="n">h</span> <span class="bp">$</span>
    <span class="k">assume</span> <span class="n">x</span> <span class="n">h1</span><span class="o">,</span>
    <span class="k">have</span> <span class="n">xA&#8321;A&#8322;</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">&#8712;</span> <span class="n">A&#8321;</span> <span class="bp">&#8746;</span> <span class="n">A&#8322;</span><span class="o">,</span> <span class="k">from</span> <span class="n">h1.left</span><span class="o">,</span>
    <span class="k">have</span> <span class="n">fxy</span> <span class="o">:</span> <span class="n">f</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">y</span><span class="o">,</span> <span class="k">from</span> <span class="n">h1.right</span><span class="o">,</span>
    <span class="n">or.elim</span> <span class="n">xA&#8321;A&#8322;</span>
      <span class="o">(</span><span class="k">assume</span> <span class="n">xA&#8321;</span><span class="o">,</span> <span class="n">or.inl</span> <span class="o">&#10216;</span><span class="n">x</span><span class="o">,</span> <span class="n">xA&#8321;</span><span class="o">,</span> <span class="n">fxy</span><span class="o">&#10217;)</span>
      <span class="o">(</span><span class="k">assume</span> <span class="n">xA&#8322;</span><span class="o">,</span> <span class="n">or.inr</span> <span class="o">&#10216;</span><span class="n">x</span><span class="o">,</span> <span class="n">xA&#8322;</span><span class="o">,</span> <span class="n">fxy</span><span class="o">&#10217;))</span>
  <span class="o">(</span><span class="k">assume</span> <span class="n">h</span> <span class="o">:</span> <span class="n">y</span> <span class="bp">&#8712;</span> <span class="n">image</span> <span class="n">f</span> <span class="n">A&#8321;</span> <span class="bp">&#8746;</span> <span class="n">image</span> <span class="n">f</span> <span class="n">A&#8322;</span><span class="o">,</span>
    <span class="n">or.elim</span> <span class="n">h</span>
      <span class="o">(</span><span class="k">assume</span> <span class="n">yifA&#8321;</span> <span class="o">:</span> <span class="n">y</span> <span class="bp">&#8712;</span> <span class="n">image</span> <span class="n">f</span> <span class="n">A&#8321;</span><span class="o">,</span>
        <span class="n">exists.elim</span> <span class="n">yifA&#8321;</span> <span class="bp">$</span>
        <span class="k">assume</span> <span class="n">x</span> <span class="n">h1</span><span class="o">,</span>
        <span class="k">have</span> <span class="n">xA&#8321;</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">&#8712;</span> <span class="n">A&#8321;</span><span class="o">,</span> <span class="k">from</span> <span class="n">h1.left</span><span class="o">,</span>
        <span class="k">have</span> <span class="n">fxy</span> <span class="o">:</span> <span class="n">f</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">y</span><span class="o">,</span> <span class="k">from</span> <span class="n">h1.right</span><span class="o">,</span>
        <span class="o">&#10216;</span><span class="n">x</span><span class="o">,</span> <span class="n">or.inl</span> <span class="n">xA&#8321;</span><span class="o">,</span> <span class="n">fxy</span><span class="o">&#10217;)</span>
      <span class="o">(</span><span class="k">assume</span> <span class="n">yifA&#8322;</span> <span class="o">:</span> <span class="n">y</span> <span class="bp">&#8712;</span> <span class="n">image</span> <span class="n">f</span> <span class="n">A&#8322;</span><span class="o">,</span>
        <span class="n">exists.elim</span> <span class="n">yifA&#8322;</span> <span class="bp">$</span>
        <span class="k">assume</span> <span class="n">x</span> <span class="n">h1</span><span class="o">,</span>
        <span class="k">have</span> <span class="n">xA&#8322;</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">&#8712;</span> <span class="n">A&#8322;</span><span class="o">,</span> <span class="k">from</span> <span class="n">h1.left</span><span class="o">,</span>
        <span class="k">have</span> <span class="n">fxy</span> <span class="o">:</span> <span class="n">f</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">y</span><span class="o">,</span> <span class="k">from</span> <span class="n">h1.right</span><span class="o">,</span>
        <span class="o">&#10216;</span><span class="n">x</span><span class="o">,</span> <span class="o">(</span><span class="n">or.inr</span> <span class="n">xA&#8322;</span><span class="o">),</span> <span class="n">fxy</span><span class="o">&#10217;)))</span>
</pre></div>
</div>
</div><p>Note that the expression <code class="docutils literal"><span class="pre">y</span> <span class="pre">&#8712;</span> <span class="pre">image</span> <span class="pre">f</span> <span class="pre">A&#8321;</span></code> expands to <code class="docutils literal"><span class="pre">&#8707;</span> <span class="pre">x,</span> <span class="pre">x</span> <span class="pre">&#8712;</span> <span class="pre">A&#8321;</span> <span class="pre">&#8743;</span> <span class="pre">f</span> <span class="pre">x</span> <span class="pre">=</span> <span class="pre">y</span></code>. We therefore need to provide three pieces of information: a value of <code class="docutils literal"><span class="pre">x</span></code>, a proof that <code class="docutils literal"><span class="pre">x</span> <span class="pre">&#8712;</span> <span class="pre">A&#8321;</span></code>, and a proof that <code class="docutils literal"><span class="pre">f</span> <span class="pre">x</span> <span class="pre">=</span> <span class="pre">y</span></code>. On the eighth line of this proof, after <code class="docutils literal"><span class="pre">or.inl</span></code>, we could justify the necessary information by writing <code class="docutils literal"><span class="pre">exists.intro</span> <span class="pre">x</span> <span class="pre">(and.intro</span> <span class="pre">xA&#8321;</span> <span class="pre">fxy)</span></code> in parentheses. But in this case Lean&#8217;s &#8220;anonymous constructor&#8221; notation, that is, the corner brackets entered with <code class="docutils literal"><span class="pre">\&lt;</span></code> and <code class="docutils literal"><span class="pre">\&gt;</span></code>, allow us to use the more compact expression <code class="docutils literal"><span class="pre">&#10216;x,</span> <span class="pre">xA&#8321;,</span> <span class="pre">fxy&#10217;</span></code>.</p>
</div>
<div class="section" id="exercises">
<h2>16.6. Exercises<a class="headerlink" href="#exercises" title="Permalink to this headline">&#182;</a></h2>
<ol class="arabic">
<li><p class="first">Fill in the <code class="docutils literal"><span class="pre">sorry</span></code>&#8217;s in the last three proofs below.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover.github.io/live/3.4.1/#code=open%20function%20int%20algebra%0A%0Adef%20f%20(x%20:%20%E2%84%A4)%20:%20%E2%84%A4%20:=%20x%20+%203%0Adef%20g%20(x%20:%20%E2%84%A4)%20:%20%E2%84%A4%20:=%20-x%0Adef%20h%20(x%20:%20%E2%84%A4)%20:%20%E2%84%A4%20:=%202%20*%20x%20+%203%0A%0Aexample%20:%20injective%20f%20:=%0Aassume%20x1%20x2,%0Aassume%20h1%20:%20x1%20+%203%20=%20x2%20+%203,%20%20%20--%20Lean%20knows%20this%20is%20the%20same%20as%20f%20x1%20=%20f%20x2%0Ashow%20x1%20=%20x2,%20from%20eq_of_add_eq_add_right%20h1%0A%0Aexample%20:%20surjective%20f%20:=%0Aassume%20y,%0Ahave%20h1%20:%20f%20(y%20-%203)%20=%20y,%20from%20calc%0A%20%20f%20(y%20-%203)%20=%20(y%20-%203)%20+%203%20:%20rfl%0A%20%20%20%20%20%20%20%20...%20=%20y%20%20%20%20%20%20%20%20%20%20%20:%20by%20rw%20sub_add_cancel,%0Ashow%20%E2%88%83%20x,%20f%20x%20=%20y,%20from%20exists.intro%20(y%20-%203)%20h1%0A%0Aexample%20(x%20y%20:%20%E2%84%A4)%20(h%20:%202%20*%20x%20=%202%20*%20y)%20:%20x%20=%20y%20:=%0Ahave%20h1%20:%202%20%E2%89%A0%20(0%20:%20%E2%84%A4),%20from%20dec_trivial,%20%20--%20this%20tells%20Lean%20to%20figure%20it%20out%20itself%0Ashow%20x%20=%20y,%20from%20eq_of_mul_eq_mul_left%20h1%20h%0A%0Aexample%20(x%20:%20%E2%84%A4)%20:%20-(-x)%20=%20x%20:=%20neg_neg%20x%0A%0Aexample%20(A%20B%20:%20Type)%20(u%20:%20A%20%E2%86%92%20B)%20(v%20:%20B%20%E2%86%92%20A)%20(h%20:%20left_inverse%20u%20v)%20:%0A%20%20%E2%88%80%20x,%20u%20(v%20x)%20=%20x%20:=%0Ah%0A%0Aexample%20(A%20B%20:%20Type)%20(u%20:%20A%20%E2%86%92%20B)%20(v%20:%20B%20%E2%86%92%20A)%20(h%20:%20left_inverse%20u%20v)%20:%0A%20%20right_inverse%20v%20u%20:=%0Ah%0A%0A--%20fill%20in%20the%20sorry's%20in%20the%20following%20proofs%0A%0Aexample%20:%20injective%20h%20:=%0Asorry%0A%0Aexample%20:%20surjective%20g%20:=%0Asorry%0A%0Aexample%20(A%20B%20:%20Type)%20(u%20:%20A%20%E2%86%92%20B)%20(v1%20:%20B%20%E2%86%92%20A)%20(v2%20:%20B%20%E2%86%92%20A)%0A%20%20(h1%20:%20left_inverse%20v1%20u)%20(h2%20:%20right_inverse%20v2%20u)%20:%20v1%20=%20v2%20:=%0Afunext%0A%20%20(assume%20x,%0A%20%20%20%20calc%0A%20%20%20%20%20%20v1%20x%20=%20v1%20(u%20(v2%20x))%20:%20sorry%0A%20%20%20%20%20%20%20...%20=%20v2%20x%20%20%20%20%20%20%20%20%20%20:%20sorry)" target="_blank">
try it!</a></div><div class="highlight-lean"><div class="highlight"><pre><span class="kn">open</span> <span class="n">function</span> <span class="n">int</span> <span class="n">algebra</span>

<span class="kd">def</span> <span class="n">f</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">&#8484;</span><span class="o">)</span> <span class="o">:</span> <span class="n">&#8484;</span> <span class="o">:=</span> <span class="n">x</span> <span class="bp">+</span> <span class="mi">3</span>
<span class="kd">def</span> <span class="n">g</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">&#8484;</span><span class="o">)</span> <span class="o">:</span> <span class="n">&#8484;</span> <span class="o">:=</span> <span class="bp">-</span><span class="n">x</span>
<span class="kd">def</span> <span class="n">h</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">&#8484;</span><span class="o">)</span> <span class="o">:</span> <span class="n">&#8484;</span> <span class="o">:=</span> <span class="mi">2</span> <span class="bp">*</span> <span class="n">x</span> <span class="bp">+</span> <span class="mi">3</span>

<span class="kd">example</span> <span class="o">:</span> <span class="n">injective</span> <span class="n">f</span> <span class="o">:=</span>
<span class="k">assume</span> <span class="n">x1</span> <span class="n">x2</span><span class="o">,</span>
<span class="k">assume</span> <span class="n">h1</span> <span class="o">:</span> <span class="n">x1</span> <span class="bp">+</span> <span class="mi">3</span> <span class="bp">=</span> <span class="n">x2</span> <span class="bp">+</span> <span class="mi">3</span><span class="o">,</span>   <span class="c1">-- Lean knows this is the same as f x1 = f x2</span>
<span class="k">show</span> <span class="n">x1</span> <span class="bp">=</span> <span class="n">x2</span><span class="o">,</span> <span class="k">from</span> <span class="n">eq_of_add_eq_add_right</span> <span class="n">h1</span>

<span class="kd">example</span> <span class="o">:</span> <span class="n">surjective</span> <span class="n">f</span> <span class="o">:=</span>
<span class="k">assume</span> <span class="n">y</span><span class="o">,</span>
<span class="k">have</span> <span class="n">h1</span> <span class="o">:</span> <span class="n">f</span> <span class="o">(</span><span class="n">y</span> <span class="bp">-</span> <span class="mi">3</span><span class="o">)</span> <span class="bp">=</span> <span class="n">y</span><span class="o">,</span> <span class="k">from</span> <span class="k">calc</span>
  <span class="n">f</span> <span class="o">(</span><span class="n">y</span> <span class="bp">-</span> <span class="mi">3</span><span class="o">)</span> <span class="bp">=</span> <span class="o">(</span><span class="n">y</span> <span class="bp">-</span> <span class="mi">3</span><span class="o">)</span> <span class="bp">+</span> <span class="mi">3</span> <span class="o">:</span> <span class="n">rfl</span>
        <span class="bp">...</span> <span class="bp">=</span> <span class="n">y</span>           <span class="o">:</span> <span class="kd">by</span> <span class="n">rw</span> <span class="n">sub_add_cancel</span><span class="o">,</span>
<span class="k">show</span> <span class="bp">&#8707;</span> <span class="n">x</span><span class="o">,</span> <span class="n">f</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">y</span><span class="o">,</span> <span class="k">from</span> <span class="n">exists.intro</span> <span class="o">(</span><span class="n">y</span> <span class="bp">-</span> <span class="mi">3</span><span class="o">)</span> <span class="n">h1</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">&#8484;</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="mi">2</span> <span class="bp">*</span> <span class="n">x</span> <span class="bp">=</span> <span class="mi">2</span> <span class="bp">*</span> <span class="n">y</span><span class="o">)</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">y</span> <span class="o">:=</span>
<span class="k">have</span> <span class="n">h1</span> <span class="o">:</span> <span class="mi">2</span> <span class="bp">&#8800;</span> <span class="o">(</span><span class="mi">0</span> <span class="o">:</span> <span class="n">&#8484;</span><span class="o">),</span> <span class="k">from</span> <span class="n">dec_trivial</span><span class="o">,</span>  <span class="c1">-- this tells Lean to figure it out itself</span>
<span class="k">show</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">y</span><span class="o">,</span> <span class="k">from</span> <span class="n">eq_of_mul_eq_mul_left</span> <span class="n">h1</span> <span class="n">h</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">&#8484;</span><span class="o">)</span> <span class="o">:</span> <span class="bp">-</span><span class="o">(</span><span class="bp">-</span><span class="n">x</span><span class="o">)</span> <span class="bp">=</span> <span class="n">x</span> <span class="o">:=</span> <span class="n">neg_neg</span> <span class="n">x</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">(</span><span class="n">u</span> <span class="o">:</span> <span class="n">A</span> <span class="bp">&#8594;</span> <span class="n">B</span><span class="o">)</span> <span class="o">(</span><span class="n">v</span> <span class="o">:</span> <span class="n">B</span> <span class="bp">&#8594;</span> <span class="n">A</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">left_inverse</span> <span class="n">u</span> <span class="n">v</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">&#8704;</span> <span class="n">x</span><span class="o">,</span> <span class="n">u</span> <span class="o">(</span><span class="n">v</span> <span class="n">x</span><span class="o">)</span> <span class="bp">=</span> <span class="n">x</span> <span class="o">:=</span>
<span class="n">h</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">(</span><span class="n">u</span> <span class="o">:</span> <span class="n">A</span> <span class="bp">&#8594;</span> <span class="n">B</span><span class="o">)</span> <span class="o">(</span><span class="n">v</span> <span class="o">:</span> <span class="n">B</span> <span class="bp">&#8594;</span> <span class="n">A</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">left_inverse</span> <span class="n">u</span> <span class="n">v</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">right_inverse</span> <span class="n">v</span> <span class="n">u</span> <span class="o">:=</span>
<span class="n">h</span>

<span class="c1">-- fill in the sorry&#39;s in the following proofs</span>

<span class="kd">example</span> <span class="o">:</span> <span class="n">injective</span> <span class="n">h</span> <span class="o">:=</span>
<span class="n">sorry</span>

<span class="kd">example</span> <span class="o">:</span> <span class="n">surjective</span> <span class="n">g</span> <span class="o">:=</span>
<span class="n">sorry</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">(</span><span class="n">u</span> <span class="o">:</span> <span class="n">A</span> <span class="bp">&#8594;</span> <span class="n">B</span><span class="o">)</span> <span class="o">(</span><span class="n">v1</span> <span class="o">:</span> <span class="n">B</span> <span class="bp">&#8594;</span> <span class="n">A</span><span class="o">)</span> <span class="o">(</span><span class="n">v2</span> <span class="o">:</span> <span class="n">B</span> <span class="bp">&#8594;</span> <span class="n">A</span><span class="o">)</span>
  <span class="o">(</span><span class="n">h1</span> <span class="o">:</span> <span class="n">left_inverse</span> <span class="n">v1</span> <span class="n">u</span><span class="o">)</span> <span class="o">(</span><span class="n">h2</span> <span class="o">:</span> <span class="n">right_inverse</span> <span class="n">v2</span> <span class="n">u</span><span class="o">)</span> <span class="o">:</span> <span class="n">v1</span> <span class="bp">=</span> <span class="n">v2</span> <span class="o">:=</span>
<span class="n">funext</span>
  <span class="o">(</span><span class="k">assume</span> <span class="n">x</span><span class="o">,</span>
    <span class="k">calc</span>
      <span class="n">v1</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">v1</span> <span class="o">(</span><span class="n">u</span> <span class="o">(</span><span class="n">v2</span> <span class="n">x</span><span class="o">))</span> <span class="o">:</span> <span class="n">sorry</span>
       <span class="bp">...</span> <span class="bp">=</span> <span class="n">v2</span> <span class="n">x</span>          <span class="o">:</span> <span class="n">sorry</span><span class="o">)</span>
</pre></div>
</div>
</div></li>
<li><p class="first">Fill in the <code class="docutils literal"><span class="pre">sorry</span></code> in the proof below.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover.github.io/live/3.4.1/#code=import%20data.set%0Aopen%20function%20set%0A%0Avariables%20%7BX%20Y%20:%20Type%7D%0Avariable%20%20f%20:%20X%20%E2%86%92%20Y%0Avariables%20A%20B%20:%20set%20X%0A%0Aexample%20:%20f%20''%20(A%20%E2%88%AA%20B)%20=%20f%20''%20A%20%E2%88%AA%20f%20''%20B%20:=%0Aeq_of_subset_of_subset%0A%20%20(assume%20y,%0A%20%20%20%20assume%20h1%20:%20y%20%E2%88%88%20f%20''%20(A%20%E2%88%AA%20B),%0A%20%20%20%20exists.elim%20h1%20$%0A%20%20%20%20assume%20x%20h,%0A%20%20%20%20have%20h2%20:%20x%20%E2%88%88%20A%20%E2%88%AA%20B,%20from%20h.left,%0A%20%20%20%20have%20h3%20:%20f%20x%20=%20y,%20from%20h.right,%0A%20%20%20%20or.elim%20h2%0A%20%20%20%20%20%20(assume%20h4%20:%20x%20%E2%88%88%20A,%0A%20%20%20%20%20%20%20%20have%20h5%20:%20y%20%E2%88%88%20f%20''%20A,%20from%20%E2%9F%A8x,%20h4,%20h3%E2%9F%A9,%0A%20%20%20%20%20%20%20%20show%20y%20%E2%88%88%20f%20''%20A%20%E2%88%AA%20f%20''%20B,%20from%20or.inl%20h5)%0A%20%20%20%20%20%20(assume%20h4%20:%20x%20%E2%88%88%20B,%0A%20%20%20%20%20%20%20%20have%20h5%20:%20y%20%E2%88%88%20f%20''%20%20B,%20from%20%E2%9F%A8x,%20h4,%20h3%E2%9F%A9,%0A%20%20%20%20%20%20%20%20show%20y%20%E2%88%88%20f%20''%20A%20%E2%88%AA%20f%20''%20B,%20from%20or.inr%20h5))%0A%20%20(assume%20y,%0A%20%20%20%20assume%20h2%20:%20y%20%E2%88%88%20f%20''%20A%20%E2%88%AA%20f%20''%20B,%0A%20%20%20%20or.elim%20h2%0A%20%20%20%20%20%20(assume%20h3%20:%20y%20%E2%88%88%20f%20''%20A,%0A%20%20%20%20%20%20%20%20exists.elim%20h3%20$%0A%20%20%20%20%20%20%20%20assume%20x%20h,%0A%20%20%20%20%20%20%20%20have%20h4%20:%20x%20%E2%88%88%20A,%20from%20h.left,%0A%20%20%20%20%20%20%20%20have%20h5%20:%20f%20x%20=%20y,%20from%20h.right,%0A%20%20%20%20%20%20%20%20have%20h6%20:%20x%20%E2%88%88%20A%20%E2%88%AA%20B,%20from%20or.inl%20h4,%0A%20%20%20%20%20%20%20%20show%20y%20%E2%88%88%20f%20''%20(A%20%E2%88%AA%20B),%20from%20%E2%9F%A8x,%20h6,%20h5%E2%9F%A9)%0A%20%20%20%20%20%20(assume%20h3%20:%20y%20%E2%88%88%20f%20''%20B,%0A%20%20%20%20%20%20%20%20exists.elim%20h3%20$%0A%20%20%20%20%20%20%20%20assume%20x%20h,%0A%20%20%20%20%20%20%20%20have%20h4%20:%20x%20%E2%88%88%20B,%20from%20h.left,%0A%20%20%20%20%20%20%20%20have%20h5%20:%20f%20x%20=%20y,%20from%20h.right,%0A%20%20%20%20%20%20%20%20have%20h6%20:%20x%20%E2%88%88%20A%20%E2%88%AA%20B,%20from%20or.inr%20h4,%0A%20%20%20%20%20%20%20%20show%20y%20%E2%88%88%20f%20''%20(A%20%E2%88%AA%20B),%20from%20%E2%9F%A8x,%20h6,%20h5%E2%9F%A9))%0A%0A--%20remember,%20x%20%E2%88%88%20A%20%E2%88%A9%20B%20is%20the%20same%20as%20x%20%E2%88%88%20A%20%E2%88%A7%20x%20%E2%88%88%20B%0Aexample%20(x%20:%20X)%20(h1%20:%20x%20%E2%88%88%20A)%20(h2%20:%20x%20%E2%88%88%20B)%20:%20x%20%E2%88%88%20A%20%E2%88%A9%20B%20:=%0Aand.intro%20h1%20h2%0A%0Aexample%20(x%20:%20X)%20(h1%20:%20x%20%E2%88%88%20A%20%E2%88%A9%20B)%20:%20x%20%E2%88%88%20A%20:=%0Aand.left%20h1%0A%0A--%20Fill%20in%20the%20proof%20below.%0A--%20(It%20should%20take%20about%208%20lines.)%0A%0Aexample%20:%20f%20''%20(A%20%E2%88%A9%20B)%20%E2%8A%86%20f%20''%20A%20%E2%88%A9%20f%20''%20B%20:=%0Aassume%20y,%0Aassume%20h1%20:%20y%20%E2%88%88%20f%20''%20(A%20%E2%88%A9%20B),%0Ashow%20y%20%E2%88%88%20f%20''%20A%20%E2%88%A9%20f%20''%20B,%20from%20sorry" target="_blank">
try it!</a></div><div class="highlight-lean"><div class="highlight"><pre><span class="kn">import</span> <span class="n">data.set</span>
<span class="kn">open</span> <span class="n">function</span> <span class="n">set</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">X</span> <span class="n">Y</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span>
<span class="kd">variable</span>  <span class="n">f</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">&#8594;</span> <span class="n">Y</span>
<span class="kd">variables</span> <span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="n">set</span> <span class="n">X</span>

<span class="kd">example</span> <span class="o">:</span> <span class="n">f</span> <span class="bp">&#39;&#39;</span> <span class="o">(</span><span class="n">A</span> <span class="bp">&#8746;</span> <span class="n">B</span><span class="o">)</span> <span class="bp">=</span> <span class="n">f</span> <span class="bp">&#39;&#39;</span> <span class="n">A</span> <span class="bp">&#8746;</span> <span class="n">f</span> <span class="bp">&#39;&#39;</span> <span class="n">B</span> <span class="o">:=</span>
<span class="n">eq_of_subset_of_subset</span>
  <span class="o">(</span><span class="k">assume</span> <span class="n">y</span><span class="o">,</span>
    <span class="k">assume</span> <span class="n">h1</span> <span class="o">:</span> <span class="n">y</span> <span class="bp">&#8712;</span> <span class="n">f</span> <span class="bp">&#39;&#39;</span> <span class="o">(</span><span class="n">A</span> <span class="bp">&#8746;</span> <span class="n">B</span><span class="o">),</span>
    <span class="n">exists.elim</span> <span class="n">h1</span> <span class="bp">$</span>
    <span class="k">assume</span> <span class="n">x</span> <span class="n">h</span><span class="o">,</span>
    <span class="k">have</span> <span class="n">h2</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">&#8712;</span> <span class="n">A</span> <span class="bp">&#8746;</span> <span class="n">B</span><span class="o">,</span> <span class="k">from</span> <span class="n">h.left</span><span class="o">,</span>
    <span class="k">have</span> <span class="n">h3</span> <span class="o">:</span> <span class="n">f</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">y</span><span class="o">,</span> <span class="k">from</span> <span class="n">h.right</span><span class="o">,</span>
    <span class="n">or.elim</span> <span class="n">h2</span>
      <span class="o">(</span><span class="k">assume</span> <span class="n">h4</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">&#8712;</span> <span class="n">A</span><span class="o">,</span>
        <span class="k">have</span> <span class="n">h5</span> <span class="o">:</span> <span class="n">y</span> <span class="bp">&#8712;</span> <span class="n">f</span> <span class="bp">&#39;&#39;</span> <span class="n">A</span><span class="o">,</span> <span class="k">from</span> <span class="o">&#10216;</span><span class="n">x</span><span class="o">,</span> <span class="n">h4</span><span class="o">,</span> <span class="n">h3</span><span class="o">&#10217;,</span>
        <span class="k">show</span> <span class="n">y</span> <span class="bp">&#8712;</span> <span class="n">f</span> <span class="bp">&#39;&#39;</span> <span class="n">A</span> <span class="bp">&#8746;</span> <span class="n">f</span> <span class="bp">&#39;&#39;</span> <span class="n">B</span><span class="o">,</span> <span class="k">from</span> <span class="n">or.inl</span> <span class="n">h5</span><span class="o">)</span>
      <span class="o">(</span><span class="k">assume</span> <span class="n">h4</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">&#8712;</span> <span class="n">B</span><span class="o">,</span>
        <span class="k">have</span> <span class="n">h5</span> <span class="o">:</span> <span class="n">y</span> <span class="bp">&#8712;</span> <span class="n">f</span> <span class="bp">&#39;&#39;</span>  <span class="n">B</span><span class="o">,</span> <span class="k">from</span> <span class="o">&#10216;</span><span class="n">x</span><span class="o">,</span> <span class="n">h4</span><span class="o">,</span> <span class="n">h3</span><span class="o">&#10217;,</span>
        <span class="k">show</span> <span class="n">y</span> <span class="bp">&#8712;</span> <span class="n">f</span> <span class="bp">&#39;&#39;</span> <span class="n">A</span> <span class="bp">&#8746;</span> <span class="n">f</span> <span class="bp">&#39;&#39;</span> <span class="n">B</span><span class="o">,</span> <span class="k">from</span> <span class="n">or.inr</span> <span class="n">h5</span><span class="o">))</span>
  <span class="o">(</span><span class="k">assume</span> <span class="n">y</span><span class="o">,</span>
    <span class="k">assume</span> <span class="n">h2</span> <span class="o">:</span> <span class="n">y</span> <span class="bp">&#8712;</span> <span class="n">f</span> <span class="bp">&#39;&#39;</span> <span class="n">A</span> <span class="bp">&#8746;</span> <span class="n">f</span> <span class="bp">&#39;&#39;</span> <span class="n">B</span><span class="o">,</span>
    <span class="n">or.elim</span> <span class="n">h2</span>
      <span class="o">(</span><span class="k">assume</span> <span class="n">h3</span> <span class="o">:</span> <span class="n">y</span> <span class="bp">&#8712;</span> <span class="n">f</span> <span class="bp">&#39;&#39;</span> <span class="n">A</span><span class="o">,</span>
        <span class="n">exists.elim</span> <span class="n">h3</span> <span class="bp">$</span>
        <span class="k">assume</span> <span class="n">x</span> <span class="n">h</span><span class="o">,</span>
        <span class="k">have</span> <span class="n">h4</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">&#8712;</span> <span class="n">A</span><span class="o">,</span> <span class="k">from</span> <span class="n">h.left</span><span class="o">,</span>
        <span class="k">have</span> <span class="n">h5</span> <span class="o">:</span> <span class="n">f</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">y</span><span class="o">,</span> <span class="k">from</span> <span class="n">h.right</span><span class="o">,</span>
        <span class="k">have</span> <span class="n">h6</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">&#8712;</span> <span class="n">A</span> <span class="bp">&#8746;</span> <span class="n">B</span><span class="o">,</span> <span class="k">from</span> <span class="n">or.inl</span> <span class="n">h4</span><span class="o">,</span>
        <span class="k">show</span> <span class="n">y</span> <span class="bp">&#8712;</span> <span class="n">f</span> <span class="bp">&#39;&#39;</span> <span class="o">(</span><span class="n">A</span> <span class="bp">&#8746;</span> <span class="n">B</span><span class="o">),</span> <span class="k">from</span> <span class="o">&#10216;</span><span class="n">x</span><span class="o">,</span> <span class="n">h6</span><span class="o">,</span> <span class="n">h5</span><span class="o">&#10217;)</span>
      <span class="o">(</span><span class="k">assume</span> <span class="n">h3</span> <span class="o">:</span> <span class="n">y</span> <span class="bp">&#8712;</span> <span class="n">f</span> <span class="bp">&#39;&#39;</span> <span class="n">B</span><span class="o">,</span>
        <span class="n">exists.elim</span> <span class="n">h3</span> <span class="bp">$</span>
        <span class="k">assume</span> <span class="n">x</span> <span class="n">h</span><span class="o">,</span>
        <span class="k">have</span> <span class="n">h4</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">&#8712;</span> <span class="n">B</span><span class="o">,</span> <span class="k">from</span> <span class="n">h.left</span><span class="o">,</span>
        <span class="k">have</span> <span class="n">h5</span> <span class="o">:</span> <span class="n">f</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">y</span><span class="o">,</span> <span class="k">from</span> <span class="n">h.right</span><span class="o">,</span>
        <span class="k">have</span> <span class="n">h6</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">&#8712;</span> <span class="n">A</span> <span class="bp">&#8746;</span> <span class="n">B</span><span class="o">,</span> <span class="k">from</span> <span class="n">or.inr</span> <span class="n">h4</span><span class="o">,</span>
        <span class="k">show</span> <span class="n">y</span> <span class="bp">&#8712;</span> <span class="n">f</span> <span class="bp">&#39;&#39;</span> <span class="o">(</span><span class="n">A</span> <span class="bp">&#8746;</span> <span class="n">B</span><span class="o">),</span> <span class="k">from</span> <span class="o">&#10216;</span><span class="n">x</span><span class="o">,</span> <span class="n">h6</span><span class="o">,</span> <span class="n">h5</span><span class="o">&#10217;))</span>

<span class="c1">-- remember, x &#8712; A &#8745; B is the same as x &#8712; A &#8743; x &#8712; B</span>
<span class="kd">example</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">X</span><span class="o">)</span> <span class="o">(</span><span class="n">h1</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">&#8712;</span> <span class="n">A</span><span class="o">)</span> <span class="o">(</span><span class="n">h2</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">&#8712;</span> <span class="n">B</span><span class="o">)</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">&#8712;</span> <span class="n">A</span> <span class="bp">&#8745;</span> <span class="n">B</span> <span class="o">:=</span>
<span class="n">and.intro</span> <span class="n">h1</span> <span class="n">h2</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">X</span><span class="o">)</span> <span class="o">(</span><span class="n">h1</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">&#8712;</span> <span class="n">A</span> <span class="bp">&#8745;</span> <span class="n">B</span><span class="o">)</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">&#8712;</span> <span class="n">A</span> <span class="o">:=</span>
<span class="n">and.left</span> <span class="n">h1</span>

<span class="c1">-- Fill in the proof below.</span>
<span class="c1">-- (It should take about 8 lines.)</span>

<span class="kd">example</span> <span class="o">:</span> <span class="n">f</span> <span class="bp">&#39;&#39;</span> <span class="o">(</span><span class="n">A</span> <span class="bp">&#8745;</span> <span class="n">B</span><span class="o">)</span> <span class="bp">&#8838;</span> <span class="n">f</span> <span class="bp">&#39;&#39;</span> <span class="n">A</span> <span class="bp">&#8745;</span> <span class="n">f</span> <span class="bp">&#39;&#39;</span> <span class="n">B</span> <span class="o">:=</span>
<span class="k">assume</span> <span class="n">y</span><span class="o">,</span>
<span class="k">assume</span> <span class="n">h1</span> <span class="o">:</span> <span class="n">y</span> <span class="bp">&#8712;</span> <span class="n">f</span> <span class="bp">&#39;&#39;</span> <span class="o">(</span><span class="n">A</span> <span class="bp">&#8745;</span> <span class="n">B</span><span class="o">),</span>
<span class="k">show</span> <span class="n">y</span> <span class="bp">&#8712;</span> <span class="n">f</span> <span class="bp">&#39;&#39;</span> <span class="n">A</span> <span class="bp">&#8745;</span> <span class="n">f</span> <span class="bp">&#39;&#39;</span> <span class="n">B</span><span class="o">,</span> <span class="k">from</span> <span class="n">sorry</span>
</pre></div>
</div>
</div></li>
</ol>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="index.html">Logic and Proof</a></h1>








<!-- <h3>Navigation</h3> -->
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="introduction.html">1. Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="propositional_logic.html">2. Propositional Logic</a></li>
<li class="toctree-l1"><a class="reference internal" href="natural_deduction_for_propositional_logic.html">3. Natural Deduction for Propositional Logic</a></li>
<li class="toctree-l1"><a class="reference internal" href="propositional_logic_in_lean.html">4. Propositional Logic in Lean</a></li>
<li class="toctree-l1"><a class="reference internal" href="classical_reasoning.html">5. Classical Reasoning</a></li>
<li class="toctree-l1"><a class="reference internal" href="semantics_of_propositional_logic.html">6. Semantics of Propositional Logic</a></li>
<li class="toctree-l1"><a class="reference internal" href="first_order_logic.html">7. First Order Logic</a></li>
<li class="toctree-l1"><a class="reference internal" href="natural_deduction_for_first_order_logic.html">8. Natural Deduction for First Order Logic</a></li>
<li class="toctree-l1"><a class="reference internal" href="first_order_logic_in_lean.html">9. First Order Logic in Lean</a></li>
<li class="toctree-l1"><a class="reference internal" href="semantics_of_first_order_logic.html">10. Semantics of First Order Logic</a></li>
<li class="toctree-l1"><a class="reference internal" href="sets.html">11. Sets</a></li>
<li class="toctree-l1"><a class="reference internal" href="sets_in_lean.html">12. Sets in Lean</a></li>
<li class="toctree-l1"><a class="reference internal" href="relations.html">13. Relations</a></li>
<li class="toctree-l1"><a class="reference internal" href="relations_in_lean.html">14. Relations in Lean</a></li>
<li class="toctree-l1"><a class="reference internal" href="functions.html">15. Functions</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">16. Functions in Lean</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#functions-and-symbolic-logic">16.1. Functions and Symbolic Logic</a></li>
<li class="toctree-l2"><a class="reference internal" href="#second-and-higher-order-logic">16.2. Second- and Higher-Order Logic</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id1">16.3. Functions in Lean</a></li>
<li class="toctree-l2"><a class="reference internal" href="#defining-the-inverse-classically">16.4. Defining the Inverse Classically</a></li>
<li class="toctree-l2"><a class="reference internal" href="#functions-and-sets-in-lean">16.5. Functions and Sets in Lean</a></li>
<li class="toctree-l2"><a class="reference internal" href="#exercises">16.6. Exercises</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="the_natural_numbers_and_induction.html">17. The Natural Numbers and Induction</a></li>
<li class="toctree-l1"><a class="reference internal" href="the_natural_numbers_and_induction_in_lean.html">18. The Natural Numbers and Induction in Lean</a></li>
<li class="toctree-l1"><a class="reference internal" href="elementary_number_theory.html">19. Elementary Number Theory</a></li>
<li class="toctree-l1"><a class="reference internal" href="combinatorics.html">20. Combinatorics</a></li>
<li class="toctree-l1"><a class="reference internal" href="the_real_numbers.html">21. The Real Numbers</a></li>
<li class="toctree-l1"><a class="reference internal" href="the_infinite.html">22. The Infinite</a></li>
<li class="toctree-l1"><a class="reference internal" href="axiomatic_foundations.html">23. Axiomatic Foundations</a></li>
</ul>


<hr />
<ul>
    
    <li class="toctree-l1"><a href="logic_and_proof.pdf">PDF version</a></li>
    
    <li class="toctree-l1"><a href="https://leanprover.github.io/">Lean Home</a></li>
    
</ul>

<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2017, Jeremy Avigad, Robert Y. Lewis, and Floris van Doorn.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.6.3</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.10</a>
      
      |
      <a href="_sources/functions_in_lean.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>