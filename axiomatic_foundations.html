
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=ascii" />
    <title>23. Axiomatic Foundations &#8212; Logic and Proof 0.1 documentation</title>
    <link rel="stylesheet" href="_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '0.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="shortcut icon" href="_static/favicon.ico"/>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="prev" title="22. The Infinite" href="the_infinite.html" />
<!-- <link href="https://fonts.googleapis.com/css?family=Sorts+Mill+Goudy" rel="stylesheet"> -->
<!-- <link href="https://fonts.googleapis.com/css?family=Average" rel="stylesheet"> -->
<!-- <link href="https://fonts.googleapis.com/css?family=EB+Garamond" rel="stylesheet"> -->

  </head>
  <body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="axiomatic-foundations">
<span id="id1"></span><h1>23. Axiomatic Foundations<a class="headerlink" href="#axiomatic-foundations" title="Permalink to this headline">&#182;</a></h1>
<p>In this final chapter, our story comes full circle. We started our journey with symbolic logic, using the propositional connectives to model logical terms like &#8220;and,&#8221; &#8220;or,&#8221; &#8220;not,&#8221; and &#8220;implies.&#8221; To that we added the quantifiers and function and relation symbols of first-order logic. From there, we moved to sets, functions, and relations, which are ubiquitous in modern mathematics; the natural numbers and induction; and then topics such as number theory, combinatorics, the real numbers, and the infinite. Here we return to symbolic logic, and see how it can be used to provide a formal foundation for all of mathematics.</p>
<p>Specifically, we will consider an axiomatic framework known as <em>Zermelo-Fraenkel set theory</em>, which was introduced early in the twentieth century. In the set-theoretic view of mathematics, every mathematical object is a set. The axioms assert the existence of sets with various properties. From the collection of all sets, we carve out the usual inhabitants of the mathematical universe, not just the various number systems we have considered, but also pairs, finite sequences, relations, functions, and so on. This provides us with an idealized foundation for everything we have done since <a class="reference internal" href="sets.html#sets"><span class="std std-numref">Chapter 11</span></a>.</p>
<p>At the end of this chapter, we will briefly describe another axiomatic framework, <em>dependent type theory</em>, which is the one used by Lean. We will see that it provides an alternative perspective on mathematical objects and constructions, but one which is nonetheless inter-interpretable with the set-theoretic point of view.</p>
<div class="section" id="basic-axioms-for-sets">
<span id="id2"></span><h2>23.1. Basic Axioms for Sets<a class="headerlink" href="#basic-axioms-for-sets" title="Permalink to this headline">&#182;</a></h2>
<p>The axioms of set theory are expressed in first-order logic, for a language with a single binary relation symbol, <span class="math">\(\mathord{\in}\)</span>. We think of the entire mathematical universe as consisting of nothing but sets; if <span class="math">\(x\)</span> and <span class="math">\(y\)</span> are sets, we can express that <span class="math">\(x\)</span> is an element of <span class="math">\(y\)</span> by writing <span class="math">\(x \in y\)</span>. The first axiom says that two sets are equal if and only if they have the same elements.</p>
<div class="math">
\[\text{Extensionality:} \;\; \forall x, y \; (x = y \leftrightarrow \forall z (z \in x \leftrightarrow z \in y))\]</div>
<p>The next axiom tells us that there is at least one interesting set in the universe, namely, the set with no element.</p>
<div class="math">
\[\text{Empty set:} \;\; \exists x \; \forall y \; y \notin x\]</div>
<p>Here, of course, <span class="math">\(x \notin y\)</span> abbreviates <span class="math">\(\neg (x \in y)\)</span>. By the axiom of extensionality, the set asserted to exist by this axiom is unique: in other words, if <span class="math">\(x_1\)</span> and <span class="math">\(x_2\)</span> each have no elements, then, vacuously, any element is in one if and only if it is in the other, so <span class="math">\(x_1 = x_2\)</span>. This justifies using the word <em>the</em> in the phrase <em>the empty set</em>. Given this fact, it should seem harmless to introduce a new symbol, <span class="math">\(\emptyset\)</span>, to denote the set matching that description. Indeed, one can show that this is case: in a precise sense, such expansions to a first-order language can be viewed as nothing more than a convenient manner of expression, and statements in the bigger language can be translated to the original language in a way that justifies all the expected inferences. We will not go into the details here, and, rather, take this fact for granted. Using the new symbol, the empty set axiom tells us the empty set satisfies the property <span class="math">\(\forall y \; y \notin \emptyset\)</span>.</p>
<p>The third axiom tells us that given two sets <span class="math">\(x\)</span> and <span class="math">\(y\)</span>, we can form a new set <span class="math">\(z\)</span> whose elements are exactly <span class="math">\(x\)</span> and <span class="math">\(y\)</span>.</p>
<div class="math">
\[\text{Pairing:} \;\; \forall x, y \; \exists z \; \forall w \; (w \in z \leftrightarrow w = x \vee w = y)\]</div>
<p>There is a stealth usage of this axiom lurking nearby. The axiom does not require that <span class="math">\(x\)</span> and <span class="math">\(y\)</span> are different, so, for example, we can take them both to be the empty set. This tells us that the set <span class="math">\(\{ \emptyset \}\)</span>, whose only element is the empty set, exists. More generally, the axiom tells us that for any <span class="math">\(x\)</span>, we have the set <span class="math">\(\{ x \}\)</span> whose only element is <span class="math">\(x\)</span>, and for any <span class="math">\(x\)</span> and <span class="math">\(y\)</span>, we have <span class="math">\(\{x, y\}\)</span>, as described above. Once again, the axiom of extensionality tells us that the sets meeting these descriptions are unique, so it is fair to use the corresponding notation. We are now off and running! We now have all of the following sets, and more:</p>
<div class="math">
\[\emptyset, \;\; \{ \emptyset \}, \; \; \{ \{ \emptyset \} \}, \;\; \{ \emptyset, \{ \emptyset \} \}, \;\; \{ \{ \{ \emptyset \} \} \}, \;\; \ldots\]</div>
<p>Still, we can never form a set with more than two elements in this way. To that end, it would be reasonable to add an axiom that asserts for every <span class="math">\(x\)</span> and <span class="math">\(y\)</span>, the set <span class="math">\(x \cup y\)</span> exists. But we can do better. Remember that if <span class="math">\(x\)</span> is any set, <span class="math">\(\bigcup x\)</span> denotes the union of all the sets in <span class="math">\(x\)</span>. In other words, for any set <span class="math">\(z\)</span>, <span class="math">\(z\)</span> is an element of <span class="math">\(\bigcup x\)</span> if and only if <span class="math">\(z\)</span> is in <span class="math">\(w\)</span> for some set <span class="math">\(w\)</span> in <span class="math">\(x\)</span>. The following axiom asserts that this set exists.</p>
<div class="math">
\[\text{Union:} \;\; \forall x \; \exists y \; \forall z \; (z \in y \leftrightarrow \exists w \; (w \in x \wedge z \in w))\]</div>
<p>Once again, this justifies the use of the <span class="math">\(\bigcup\)</span> notation. We get the ordinary binary union using this axiom together with pairing, since we have <span class="math">\(x \cup y = \bigcup \{ x, y \}\)</span>.</p>
<p>At this stage, it will be useful to invoke some additional notation that was first introduced in our informal presentation of sets. If <span class="math">\(A\)</span> is any first-order formula in the language of set theory, <span class="math">\(\forall x \in y \; A\)</span> abbreviates <span class="math">\(\forall x \; (x \in y \rightarrow A)\)</span> and <span class="math">\(\exists x \in y \; A\)</span> abbreviates <span class="math">\(\exists x \; (x \in y \wedge A)\)</span>, relativizing the quantifiers as described in <a class="reference internal" href="first_order_logic.html#relativization-and-sorts"><span class="std std-numref">Section 7.4</span></a>. The expression <span class="math">\(x \subseteq y\)</span> abbreviates <span class="math">\(\forall z \in x \; (z \in y)\)</span>, as you would expect.</p>
<p>The next axiom asserts that for every set <span class="math">\(x\)</span>, the power set, <span class="math">\(\mathcal{P}(x)\)</span> exists.</p>
<div class="math">
\[\text{Power Set:} \;\; \forall x \; \exists y \; \forall z \; (z \in y \leftrightarrow z \subseteq x)\]</div>
<p>We have begun to populate the universe with basic set constructions. It is the next axiom, however, that gives set theory its remarkable flexibility. Properly speaking, it is not a single axiom, but a <em>schema</em>, an infinite family of axioms given by a single template. The schema is meant to justify set-builder notation <span class="math">\(\{ w \mid \ldots \}\)</span> that was ubiquitous in <a class="reference internal" href="sets.html#sets"><span class="std std-numref">Chapter 11</span></a>. The first question we need to address is what we are allowed to write in place of the ellipsis. In our informal presentation of set theory, we said that one can define a set using any property, but that only prompts the question here as to what counts as a &#8220;property.&#8221; Axiomatic set theory provides a simple but powerful answer: we can use any first-order formula in the language of set theory.</p>
<p>Another concern centers around Russell&#8217;s paradox, as discussed in <a class="reference internal" href="sets.html#elementary-set-theory"><span class="std std-numref">Section 11.1</span></a>. Any theory that allows us to define the set <span class="math">\(\{ w \mid w \notin w \}\)</span> is inconsistent, since if we call this set <span class="math">\(z\)</span>, we can show <span class="math">\(z \in z\)</span> if and only if <span class="math">\(z \notin z\)</span>, which is a contradiction. Once again, set theory offers a simple and elegant solution: for any formula <span class="math">\(A(z)\)</span> and set <span class="math">\(y\)</span>, we can instead form the set <span class="math">\(\{ w \in y \mid A(w) \}\)</span>, consisting of the elements of <span class="math">\(y\)</span> that satisfy <span class="math">\(A\)</span>. In other words, we have to first use the other axioms of set theory to form a set <span class="math">\(y\)</span> that is big enough to include all the elements that we want to consider, and then use the formula <span class="math">\(A\)</span> to pick out the ones we want.</p>
<p>The axiom schema we want is called <em>separation</em>, because we use it to separate the elements we want from those in a bigger collection.</p>
<div class="math">
\[\text{Separation:} \;\; \forall x_1, x_2, \ldots, x_n, y \; \exists z \; \forall w \; (w \in z \leftrightarrow w \in y \wedge A(w,x_1, x_2, \ldots, x_n))\]</div>
<p>Here, <span class="math">\(A\)</span> can be any formula, and the list of variables <span class="math">\(x_1, \ldots, x_n\)</span> that are shown indicate that the formula <span class="math">\(A\)</span> can have some parameters, in which case the set we form depends on these values. For example, in ordinary mathematics, given a number <span class="math">\(m\)</span> we can form the set <span class="math">\(\{ n \in \mathbb{N} \mid \mathit{prime}(n) \wedge n &gt; m\}\)</span>. In this example, the description involves <span class="math">\(m\)</span> and <span class="math">\(n\)</span>, and the set so defined depends on <span class="math">\(m\)</span>.</p>
<p>We could use the separation axiom to simplify the previous axioms. For example, as long as we know that <em>any</em> set <span class="math">\(x\)</span> exists, we can define the empty set as <span class="math">\(\{ y \in x \mid \bot \}\)</span>. Similarly, in the pairing axiom, it is enough to assert that there is a set that contains <span class="math">\(x\)</span> and <span class="math">\(y\)</span> as elements, because then we can use separation to carve out the set whose elements are exactly <span class="math">\(x\)</span> and <span class="math">\(y\)</span>.</p>
<p>These are only the first six axioms of set theory; we have four more to go. But these axioms alone provide a foundation for reasoning about sets, relations, and functions, as we did in <a class="reference internal" href="sets.html#sets"><span class="std std-numref">Chapter 11</span></a>, <a class="reference internal" href="relations.html#relations"><span class="std std-numref">Chapter 13</span></a>, and <a class="reference internal" href="functions.html#functions"><span class="std std-numref">Chapter 15</span></a>. For example, we have already defined the union operation, and we can define set intersection <span class="math">\(x \cap y\)</span> as <span class="math">\(\{ z \in x \cup y \mid z \in x \wedge z \in y \}\)</span>.  We cannot define arbitrary set complements; for example, the exercises ask you to show that in set theory we can prove that there is no set that contains all sets, and so the complement of the empty set does not exist. But given any two sets <span class="math">\(x\)</span> and <span class="math">\(y\)</span>, we can define their difference <span class="math">\(x \setminus y\)</span> as <span class="math">\(\{ z \in x \mid z \notin y \}\)</span>. The exercises below ask you to show that we can also define indexed unions and intersections, once we have developed the notion of a function.</p>
<p>We would like to define a binary relation between two sets <span class="math">\(x\)</span> and <span class="math">\(y\)</span> to be a subset of <span class="math">\(x \times y\)</span>, but we first have to define the cartesian product <span class="math">\(x \times y\)</span>. Remember that in <a class="reference internal" href="sets.html#cartesian-product-and-power-set"><span class="std std-numref">Section 11.4</span></a> we defined the ordered pair <span class="math">\((u, v)\)</span> to be the set <span class="math">\(\{ \{ u \}, \{ u, v \} \}\)</span>. As a result, we can use the separation axiom to define</p>
<div class="math">
\[x \times y = \{ z \in \ldots \mid \exists u \in x \; \exists v \in y \; (z = (u, v)) \}\]</div>
<p>provided we can prove the existence of a set big enough to fill the &#8220;&#8230;.&#8221; In the exercises below, we ask you to show that the set <span class="math">\(\mathcal P (\mathcal P (x \cup y))\)</span> contains all the relevant ordered pairs. A binary relation <span class="math">\(r\)</span> on <span class="math">\(x\)</span> and <span class="math">\(y\)</span> is then just a subset of <span class="math">\(x \times y\)</span>, where we interpret <span class="math">\(r(u, v)\)</span> as <span class="math">\((u, v) \in r\)</span>. We can think of ordered triples from the sets <span class="math">\(x\)</span>, <span class="math">\(y\)</span>, <span class="math">\(z\)</span> as elements of <span class="math">\(x \times (y \times z)\)</span> and so on. This gives us ternary relations, four-place relations, and so on.</p>
<p>Now we can say that a function <span class="math">\(f : x \to y\)</span> is really a binary relation satisfying <span class="math">\(\forall u \in x \; \exists! v \in y \; f(u, v)\)</span>, and we write <span class="math">\(f(u) = v\)</span> when <span class="math">\(v\)</span> is the unique element satisfying <span class="math">\(f(u, v)\)</span>. A function <span class="math">\(f\)</span> taking arguments from sets <span class="math">\(x\)</span>, <span class="math">\(y\)</span>, and <span class="math">\(z\)</span> and returning an element of <cite>w</cite> can be interpreted as a function <span class="math">\(f : x \times y \times z \to w\)</span>, and so on.</p>
<p>With sets, relations, and functions, we have the basic infrastructure we need to do mathematics. All we are missing at this point are some interesting sets and structures to work with. For example, it would be nice to have a set of natural numbers, <span class="math">\(\mathbb{N}\)</span>, with all the properties we expect it to have. So let us turn to that next.</p>
</div>
<div class="section" id="the-axiom-of-infinity">
<h2>23.2. The Axiom of Infinity<a class="headerlink" href="#the-axiom-of-infinity" title="Permalink to this headline">&#182;</a></h2>
<p>With the axioms we have so far, we can form lots of finite sets, starting with <span class="math">\(\emptyset\)</span> and iterating pairing, union, powerset, and separation constructions. This will give us sets like</p>
<div class="math">
\[\emptyset, \{ \emptyset \}, \{ \{ \emptyset \} \}, \{ \emptyset, \{ \emptyset \} \}, \{ \{ \{ \emptyset \} \} \}, \ldots\]</div>
<p>But the axioms so far do not allow us to define sets that are more interesting than these. In particular, none of the axioms gives us an infinite set. So we need a further axiom to tell us that such a set exists.</p>
<p>Remember that in <a class="reference internal" href="the_natural_numbers_and_induction.html#the-natural-numbers-and-induction"><span class="std std-numref">Chapter 17</span></a> we characterized the natural numbers as a set with a distinguished element, <span class="math">\(0\)</span>, and an injective operation <span class="math">\(\mathit{succ}\)</span>, satisfying the principles of induction and recursive definition. In set theory, everything is a set, so if we want to represent the natural numbers in that framework, we need to identify them with particular sets. There is a natural choice for <span class="math">\(0\)</span>, namely, the empty set, <span class="math">\(\emptyset\)</span>. For a successor operation, we will use the function <span class="math">\(\mathit{succ}\)</span> defined by <span class="math">\(\mathit{succ}(x) = x \cup \{ x \}\)</span>. The choice is a bit of a hack; the best justification for the definition is that it works. With this definition, the first few natural numbers are as follows:</p>
<div class="math">
\[0 = \emptyset, \;\; 1 = \{ \emptyset \}, \;\; 2 = \{ \emptyset, \{ \emptyset \} \}, \;\; 3 = \{ \emptyset, \{ \emptyset \}, \{ \emptyset, \{ \emptyset \} \} \}, \;\; \ldots\]</div>
<p>It is more perspicuous to write them as follows:</p>
<div class="math">
\[0 = \emptyset, \;\; 1 = \{ 0 \}, \;\; 2 = \{ 0, 1 \}, \;\; 3 = \{ 0, 1, 2 \}, \;\; 4 = \{ 0, 1, 2, 3 \}, \;\; \ldots\]</div>
<p>In general, <span class="math">\(n+1\)</span> is represented by the set <span class="math">\(\{ 0, 1, \ldots, n \}\)</span>, in which case, <span class="math">\(m \in n\)</span> is the same as <span class="math">\(m &lt; n\)</span>. This is just an incidental property of our encoding, but it is a rather charming one.</p>
<p>Recall from <a class="reference internal" href="the_natural_numbers_and_induction.html#the-natural-numbers-and-induction"><span class="std std-numref">Chapter 17</span></a> that we can characterize the set of natural numbers as follows:</p>
<ul class="simple">
<li>There is an element <span class="math">\(0 \in \mathbb{N}\)</span> and there is an injective function <span class="math">\(\mathit{succ} : \mathbb{N} \to \mathbb{N}\)</span>, with the additional property that <span class="math">\(\mathit{succ}(x) \ne 0\)</span> for any <span class="math">\(x\)</span> in <span class="math">\(\mathbb{N}\)</span>.</li>
<li>The set <span class="math">\(\mathbb{N}\)</span> satisfies the principle of induction: if <span class="math">\(x\)</span> is a subset of <span class="math">\(\mathbb{N}\)</span> that contains <span class="math">\(0\)</span> and is closed under <span class="math">\(\mathit{succ}\)</span> (that is, whenever <span class="math">\(z\)</span> is in <span class="math">\(\mathbb{N}\)</span>, so is <span class="math">\(\mathit{succ}\)</span>), then <span class="math">\(x = \mathbb{N}\)</span>.</li>
</ul>
<p>We have already settled on the definitions of <span class="math">\(0\)</span> and <span class="math">\(\mathit{succ}\)</span>, but we don&#8217;t yet have any set that contains the first and is closed under applying the second. The axiom of infinity asserts precisely that there exists such a set.</p>
<div class="math">
\[\text{Infinity:} \;\; \exists x \; (\emptyset \in x \wedge \forall y \; (y \in x \rightarrow y \cup \{ y \} \in x))\]</div>
<p>Say a set <span class="math">\(x\)</span> is <em>inductive</em> if it satisfies the property after the existential quantifier, namely, that it contains the empty set and is closed under our successor operation. Notice that the set of natural numbers, which we are still trying to define formally, has this property. The axiom of infinity asserts the existence of <em>some</em> inductive set, but not necessarily the natural numbers themselves; an inductive set can have other things in it as well. In a sense, the principle of induction says that the natural numbers is the <em>smallest</em> inductive set. So we need a way to separate that set from the one asserted to exist by the axiom of infinity.</p>
<p>Let <span class="math">\(x\)</span> be any inductive set, as asserted to exist by the axiom of infinity. Let</p>
<div class="math">
\[y = \bigcap \{ z \subseteq x \mid \mbox{$z$ is inductive} \}.\]</div>
<p>Here <span class="math">\(z \subseteq x\)</span> can also be written <span class="math">\(z \in \mathcal P(x)\)</span>, so the inside set exists by the separation axiom. According to this definition, <span class="math">\(y\)</span> is the intersection of every inductive subset of <span class="math">\(x\)</span>, so an element <span class="math">\(w\)</span> is in <span class="math">\(y\)</span> if and only if <span class="math">\(w\)</span> is in every inductive subset of <span class="math">\(x\)</span>. We claim that <span class="math">\(y\)</span> itself is inductive. First, we have <span class="math">\(\emptyset \in y\)</span>, since the empty set is an element of every inductive set. Next, suppose <span class="math">\(w\)</span> is in <span class="math">\(y\)</span>. Then <span class="math">\(w\)</span> is in every inductive subset of <span class="math">\(x\)</span>. But since every inductive set is closed under successor, <span class="math">\(\mathit{succ}(w)\)</span> is in every inductive subset of <span class="math">\(x\)</span>. So <span class="math">\(\mathit{succ}(w)\)</span> is in the intersection of all inductive subsets of <span class="math">\(x\)</span>&#8212;which is <span class="math">\(y\)</span>!</p>
<p>It quickly follows that <span class="math">\(y\)</span> is a subset of <em>every</em> inductive set. To see this, suppose that <span class="math">\(z\)</span> is inductive. You can check that <span class="math">\(z \cap x\)</span> is inductive, and thus <span class="math">\(y \subseteq z \cap x \subseteq z\)</span>.</p>
<p>The more interesting point is that <span class="math">\(y\)</span> also satisfies the principle of induction. To see this, suppose <span class="math">\(u \subseteq y\)</span> contains the empty set and is closed under <span class="math">\(\mathit{succ}\)</span>. Then <span class="math">\(u\)</span> is inductive, and since <span class="math">\(y\)</span> is a subset of every inductive set, we have <span class="math">\(y \subseteq u\)</span>. Since we assumed <span class="math">\(u \subseteq y\)</span>, we have <span class="math">\(u = y\)</span>, which is what we want.</p>
<p>To summarize, then, we have proved the existence of a set that contains <span class="math">\(0\)</span> and is closed under a successor operation and satisfies the induction axiom. Moreover, there is only one such set: if <span class="math">\(y_1\)</span> and <span class="math">\(y_2\)</span> both have this property, then so does <span class="math">\(y_1 \cap y_2\)</span>, and by the induction principle, this intersection has to be equal to both <span class="math">\(y_1\)</span> and <span class="math">\(y_2\)</span>, in which case <span class="math">\(y_1\)</span> and <span class="math">\(y_2\)</span> are equal. It then makes sense to call the unique set with these properties the <em>natural numbers</em>, and denote it by the symbol <span class="math">\(\mathbb{N}\)</span>.</p>
<p>There is only one piece of the puzzle missing. It is clear from the definition that <span class="math">\(0\)</span> is not the successor of any number, but it is not clear that the successor function is injective. We can prove that by first noticing that the natural numbers, as we have defined them, have a peculiar property: if <span class="math">\(z\)</span> is a natural number, <span class="math">\(y\)</span> is an element of <span class="math">\(z\)</span>, and <span class="math">\(x\)</span> is an element of <span class="math">\(y\)</span>, then <span class="math">\(x\)</span> is an element of <span class="math">\(z\)</span>. This says exactly that the <span class="math">\(\in\)</span> relation is transitive on natural numbers, which is not surprising, since we have noted that <span class="math">\(\in\)</span> on the natural numbers, under our representation, coincides with <span class="math">\(&lt;\)</span>. To prove this claim formally, say that a set <span class="math">\(z\)</span> is <em>transitive</em> if it has the property just mentioned, namely, that every element of an element of <span class="math">\(z\)</span> is an element of <cite>z</cite>. This is equivalent to saying that for every <span class="math">\(y \in z\)</span>, we have <span class="math">\(y \subseteq z\)</span>.</p>
<hr class="docutils" />
<p><strong>Lemma.</strong> Every natural number is transitive.</p>
<p><strong>Proof.</strong> By induction on the natural numbers. Clearly, <span class="math">\(\emptyset\)</span> is transitive. Suppose <span class="math">\(x\)</span> is transitive, and suppose <span class="math">\(y \in \mathit{succ}(x)\)</span> and <span class="math">\(z \in y\)</span>. Since <span class="math">\(\mathit{succ}(x) = x \cup \{ x \}\)</span>, we have <span class="math">\(y \in x\)</span> or <span class="math">\(y \in \{x\}\)</span>. If <span class="math">\(y \in x\)</span>, then by the inductive hypothesis, we have <span class="math">\(z \in x\)</span>, and hence <span class="math">\(z \in \mathit{succ}(x)\)</span>. Otherwise, we have <span class="math">\(y \in \{ x \}\)</span>, and so <span class="math">\(y = x\)</span>. In that case, again we have <span class="math">\(z \in x\)</span>, and hence <span class="math">\(z \in \mathit{succ}(x)\)</span>.</p>
<hr class="docutils" />
<p>The next lemma shows that, on transitive sets, union acts like the predecessor operation.</p>
<hr class="docutils" />
<p><strong>Lemma.</strong> If <span class="math">\(x\)</span> is transitive, then <span class="math">\(\bigcup \mathit{succ}(x) = x\)</span>.</p>
<p><strong>Proof</strong>. Suppose <span class="math">\(y\)</span> is in <span class="math">\(\bigcup \mathit{succ}(x) = \bigcup (x \cup \{ x \})\)</span>. Then either <span class="math">\(y \in z\)</span> for some <span class="math">\(z \in x\)</span>, or <span class="math">\(y \in x\)</span>. In the first case, also have <span class="math">\(y \in x\)</span>, since <span class="math">\(x\)</span> is transitive.</p>
<p>Conversely, suppose <span class="math">\(y\)</span> is in <span class="math">\(x\)</span>. Then <span class="math">\(y\)</span> is in <span class="math">\(\bigcup \mathit{succ}(x)\)</span>, since we have <span class="math">\(x \in \mathit{succ}(x)\)</span>.</p>
<p><strong>Theorem.</strong> <span class="math">\(\mathit{succ}\)</span> is injective on <span class="math">\(\mathbb{N}\)</span>.</p>
<p><strong>Proof.</strong> Suppose <span class="math">\(x\)</span> and <span class="math">\(y\)</span> are in <span class="math">\(\mathbb{N}\)</span>, and <span class="math">\(\mathit{succ}(x) = \mathit{succ}(y)\)</span>. Then <span class="math">\(x\)</span> and <span class="math">\(y\)</span> are both transitive, and we have <span class="math">\(x = \bigcup \mathit{succ}(x) = \bigcup \mathit{succ}(y) = y\)</span>.</p>
<hr class="docutils" />
<p>With that, we are off and running. Although we will not present the details here, using the principle of induction we can justify the principle of recursive definition. We can then go on to define the basic operations of arithmetic and derive their properties, as done in <a class="reference internal" href="the_natural_numbers_and_induction.html#the-natural-numbers-and-induction"><span class="std std-numref">Chapter 17</span></a>. We can go on to define the integers, the rational numbers, and the real numbers, as described in Chapter <a class="reference internal" href="the_real_numbers.html#the-real-numbers"><span class="std std-numref">Chapter 21</span></a>, and to develop subjects like number theory and combinatorics, as described in Chapters <a class="reference internal" href="elementary_number_theory.html#elementary-number-theory"><span class="std std-numref">Chapter 19</span></a> and <a class="reference internal" href="combinatorics.html#combinatorics"><span class="std std-numref">Chapter 20</span></a>. In fact, it seems that any reasonable branch of mathematics can be developed formally on the basis of axiomatic set theory. There are pitfalls, for example, having to do with large collections: for example, just as it is inconsistent to postulate the existence of a set of all sets, in the same way, there is no collection of all partial orders, or all groups. So when interpreting some mathematical claims, care has to be taken in some cases to restrict to sufficiently large collections of such objects. But this rarely amounts to more than careful bookkeeping, and it is a remarkable fact that, for the most part, the axioms of set theory are flexible and powerful enough to justify most ordinary mathematical constructions.</p>
</div>
<div class="section" id="the-remaining-axioms">
<span id="id3"></span><h2>23.3. The Remaining Axioms<a class="headerlink" href="#the-remaining-axioms" title="Permalink to this headline">&#182;</a></h2>
<p>The seven axioms we have seen are quite powerful, and suffice to represent large portions of mathematics. We discuss the remaining axioms of Zermelo-Fraenkel set theory here.</p>
<p>So far, none of the axioms we have seen rule out the possibility that a set <span class="math">\(x\)</span> can be an element of itself, that is, that we can have <span class="math">\(x \in x\)</span>. The following axiom precludes that.</p>
<div class="math">
\[\text{Foundation} \;\; \forall x \; (\exists y \; y \in x \to \exists y \in x \; \forall z \in x \; z \notin y)))\]</div>
<p>The axiom says that if <span class="math">\(x\)</span> is a nonempty set, there is an element <span class="math">\(y\)</span> of <span class="math">\(x\)</span> with the property that no element of <span class="math">\(y\)</span> is again an element of <span class="math">\(x\)</span>. This implies we cannot have a descending chain of sets, each one an element of the one before:</p>
<div class="math">
\[x_1 \ni x_2 \ni x_3 \ni \ldots\]</div>
<p>If we apply the axiom of foundation to the set <span class="math">\(\{x_1, x_2, x_3, \ldots\}\)</span>, we find that some element <span class="math">\(x_i\)</span> does not contain any others, which is only possible if the sequence has terminated with <span class="math">\(x_i\)</span>. In other words, the axiom implies (and is in fact equivalent to) the statement that the elementhood relation is <em>well founded</em>, which explains the name.</p>
<p>The axioms listed in the previous section tell a story of how sets come to be: we start with the empty set, and keep applying constructions like power set, union, and separation, to build more sets. Set theorists often imagine the hierarchy of sets as forming a big V, with the empty set at the bottom and a set at any higher level comprising, as its elements, sets that appear in levels below. In a precise sense (which we will not spell out here), the axiom of foundation says that every set arises in such a way.</p>
<p>Now consider the following sequence of sets:</p>
<div class="math">
\[\mathbb{N}, \;\; \mathcal P(\mathbb{N}), \;\; \mathcal P(\mathcal P(\mathbb{N}), \;\; \mathcal P (\mathcal P (\mathcal P (\mathbb{N}))), \;\; \ldots\]</div>
<p>It is consistent with all the axioms we have seen so far that every set in the mathematical universe is an element of one of these. That still gives us a lot of sets, but, since we have described that sequence, we can just as well imagine a set that contains all of them:</p>
<div class="math">
\[\{ \mathbb{N}, \;\; \mathcal P(\mathbb{N}), \;\; \mathcal P(\mathcal P(\mathbb{N}), \;\; \mathcal P (\mathcal P (\mathcal P (\mathbb{N}))), \;\; \ldots \}.\]</div>
<p>The following axiom implies the existence of such a set.</p>
<div class="math">
\[\begin{split}\text{Replacement:} \;\; \forall x, y_1, \ldots, y_n \;\; (\forall z \in x \; \exists ! w \; A(z, w, y_1, \ldots, y_n) \rightarrow \\
\exists u \; \forall w \; (w \in u \leftrightarrow \exists z \in x \; A(z, w, y_1, \ldots, y_n)))\end{split}\]</div>
<p>Like the axiom of separation, this axiom is really a schema, which is to say, a separate axiom for each formula <span class="math">\(A\)</span>. Here, too, the variables <span class="math">\(y_1, y_2, \ldots, y_n\)</span> are free variables that can occur in <span class="math">\(A\)</span>. To understand the axiom, it is easiest to think of them as parameters that are fixed in the background, and then ignore them. The axioms says that if, for every <span class="math">\(z\)</span> in <span class="math">\(x\)</span> there is a unique <span class="math">\(w\)</span> satisfying <span class="math">\(A(z,w)\)</span>, then there is a single set, <span class="math">\(u\)</span>, that consists of the <span class="math">\(w\)</span> values corresponding to every such <span class="math">\(z\)</span>. In other words, if you think of <span class="math">\(A\)</span> as a function whose domain is <span class="math">\(x\)</span>, the axiom asserts that the range of that function exists. In the example above, <span class="math">\(x\)</span> is the natural numbers, and <span class="math">\(A(z, w)\)</span> says that <span class="math">\(w\)</span> is the <span class="math">\(z\)</span>-fold iterate of the power set of the natural numbers.</p>
<p>The nine axioms we have listed so far comprise what is known as <em>Zermelo-Fraenkel Set Theory</em>. There is on additional axiom, the axiom of choice, which is usually listed separately for historical reasons: it was once considered controversial, and in the early days, mathematicians considered it important to keep track of whether the axiom was actually used in a proof. There are many equivalent formulations, but this one is one of the most straightforward.</p>
<div class="math">
\[\text{Choice:} \;\; \forall x \; (\emptyset \notin x \rightarrow \exists f : x \to \bigcup x \; \forall y \in x \; f(y) \in y)\]</div>
<p>The axiom says that for any collection <span class="math">\(x\)</span> of nonempty sets, there is a function <span class="math">\(f\)</span> that selects an element from each one. We used this axiom, informally, in <a class="reference internal" href="functions.html#injective-surjective-and-bijective-functions"><span class="std std-numref">Section 15.2</span></a> to show that every surjective function has a right inverse. In fact, this last statement can be shown to be equivalent to the axiom of choice on the basis of the other axioms.</p>
<p>To summarize, then, the axioms of Zermelo-Fraenkel Set Theory with the axiom of choice are as follows:</p>
<ol class="arabic">
<li><p class="first">Extensionality:</p>
<blockquote>
<div><div class="math">
\[\forall x, y \; (x = y \leftrightarrow \forall z (z \in x \leftrightarrow z \in y))\]</div>
</div></blockquote>
</li>
<li><p class="first">Empty set:</p>
<blockquote>
<div><div class="math">
\[\exists x \; \forall y \; y \notin x\]</div>
</div></blockquote>
</li>
<li><p class="first">Pairing:</p>
<blockquote>
<div><div class="math">
\[\forall x, y \; \exists z \; \forall w \; (w \in z \leftrightarrow w = x \vee w = y)\]</div>
</div></blockquote>
</li>
<li><p class="first">Union:</p>
<blockquote>
<div><div class="math">
\[\forall x \; \exists y \; \forall z \; (z \in y \leftrightarrow \exists w \; (w \in x \wedge z \in w))\]</div>
</div></blockquote>
</li>
<li><p class="first">Power set:</p>
<blockquote>
<div><div class="math">
\[\forall x \; \exists y \; \forall z \; (z \in y \leftrightarrow z \subseteq y)\]</div>
</div></blockquote>
</li>
<li><p class="first">Separation:</p>
<blockquote>
<div><div class="math">
\[\forall x_1, x_2, \ldots, x_n, y \; \exists z \; \forall w \; (w \in z \leftrightarrow w \in y \wedge A(w,x_1, x_2, \ldots, x_n))\]</div>
</div></blockquote>
</li>
<li><p class="first">Infinity:</p>
<blockquote>
<div><div class="math">
\[\exists x \; (\emptyset \in x \wedge \forall y \; (y \in x \rightarrow y \cup \{ y \} \in x)\]</div>
</div></blockquote>
</li>
<li><p class="first">Foundation:</p>
<blockquote>
<div><div class="math">
\[\forall x \; (\exists y \; y \in x \to \exists y \in x \; \forall z \in x \; z \notin y)))\]</div>
</div></blockquote>
</li>
<li><p class="first">Replacement:</p>
<blockquote>
<div><div class="math">
\[\begin{split}\forall x, y_1, \ldots, y_n \;\; (\forall z \in x \; \exists ! w \; A(z, w, y_1, \ldots, y_n) \rightarrow \\
\exists u \; \forall w \; (w \in u \leftrightarrow \exists z \in x \; A(z, w, y_1, \ldots, y_n)))\end{split}\]</div>
</div></blockquote>
</li>
<li><p class="first">Choice:</p>
<blockquote>
<div><div class="math">
\[\forall x \; (\emptyset \notin x \rightarrow \exists f : x \to \bigcup x \; \forall y \in x \; f(y) \in y)\]</div>
</div></blockquote>
</li>
</ol>
</div>
<div class="section" id="type-theory">
<h2>23.4. Type Theory<a class="headerlink" href="#type-theory" title="Permalink to this headline">&#182;</a></h2>
<p>As a foundation for mathematics, Zermelo-Fraenkel set theory is appealing. The underlying logic, first-order logic, provides the basic logical framework for quantifiers and the logical connectives. On top of that, the theory describes a single, intuitively natural concept, that of a set of elements. The axioms are plausible eminently reasonable. It is remarkable that virtually all of modern mathematics can be reduced to such simple terms.</p>
<p>There are other foundations on offer, however. These tend to be largely inter-interpretable with set theory. After all, set-theoretic language is now ubiquitous in everyday mathematics, so any reasonable foundation should be able to make sense of such language. On the other hand, we have already noted that set theory is remarkably expressive and robust, and so it should not be surprising that other foundational approaches can often be understood in set-theoretic terms.</p>
<p>This is, in particular, true of <em>dependent type theory</em>, which is the basis of the Lean theorem prover. The syntax of type theory is more complicated than that of set theory. In set theory, there is only one kind of object; officially, everything is a set. In contrast, in type theory, every well-formed expression in Lean has a <em>type</em>, and there is a rich vocabulary of defining types.</p>
<p>In fact, Lean is based on a version of an axiomatic framework known as the <em>Calculus of Inductive Constructions</em>, which provides all of the following:</p>
<ul class="simple">
<li>A hierarchy of <em>type universes</em>, <code class="docutils literal"><span class="pre">Type</span> <span class="pre">0</span></code>, <code class="docutils literal"><span class="pre">Type</span> <span class="pre">1</span></code>, <code class="docutils literal"><span class="pre">Type</span> <span class="pre">2</span></code>, &#8230; and a special type <code class="docutils literal"><span class="pre">Prop</span></code>. The expression <code class="docutils literal"><span class="pre">Type</span></code> abbreviates <code class="docutils literal"><span class="pre">Type</span> <span class="pre">0</span></code>, and saying <code class="docutils literal"><span class="pre">T</span> <span class="pre">:</span> <span class="pre">Type</span></code> can be interpreted as saying that <code class="docutils literal"><span class="pre">T</span></code> is a datatype. The type <code class="docutils literal"><span class="pre">Prop</span></code> is the type of propositions.</li>
<li><em>Dependent function types</em> <code class="docutils literal"><span class="pre">&#928;</span> <span class="pre">x</span> <span class="pre">:</span> <span class="pre">A,</span> <span class="pre">B</span> <span class="pre">x</span></code>. An element <code class="docutils literal"><span class="pre">f</span></code> of this type is a function which maps any element <code class="docutils literal"><span class="pre">a</span></code> of type <code class="docutils literal"><span class="pre">A</span></code> to an element <code class="docutils literal"><span class="pre">f</span> <span class="pre">a</span></code> of type <code class="docutils literal"><span class="pre">B</span> <span class="pre">a</span></code>. The fact that the type of the output depends on the type of the input is what makes the function &#8220;dependent.&#8221; In the case where the output type does not depend on the input, we have the simple function type <code class="docutils literal"><span class="pre">A</span> <span class="pre">&#8594;</span> <span class="pre">B</span></code>.</li>
<li><em>Inductive types</em>, like the natural numbers, specified by <em>constructors</em>, like zero and successor. Each such type comes with principles of induction and recursion.</li>
</ul>
<p>These constructions account for both the underlying logic of assertions (that is, the propositions) as well as the objects of the universe, which are elements of the ordinary types.</p>
<p>It is straightforward to interpret type theory in set theory, since we can view each type as a set. The type universes are simply large collections of sets, and dependent function types and inductive types can be explained in terms of set-theoretic constructions. We can view <code class="docutils literal"><span class="pre">Prop</span></code> as the set <span class="math">\(\{ \top, \bot \}\)</span> of truth values, just as we did when we described truth-table semantics for propositional logic.</p>
<p>Given this last fact, why not just use set theory instead of type theory for interactive theorem proving? Some interactive theorem provers do just that. But type theory has some advantages:</p>
<ul class="simple">
<li>The fact that the rules for forming expressions are so rigid makes it easier for the system to recognize typographical errors and provide useful feedback. In type theory, if <code class="docutils literal"><span class="pre">f</span></code> has type <code class="docutils literal"><span class="pre">&#8469;</span> <span class="pre">&#8594;</span> <span class="pre">&#8469;</span></code> it can be applied only to a natural number, and a theorem prover can flag an error if the argument has the wrong type. In set theory, anything can be applied to anything, whether or not doing so really makes sense.</li>
<li>Again, because the rules for forming expressions are so rigid, the system can infer useful information from the components of an expression, whereas set theory would require us to make such information explicit. For example, with <code class="docutils literal"><span class="pre">f</span></code> as above, a theorem prover can infer that a variable <code class="docutils literal"><span class="pre">x</span></code> in <code class="docutils literal"><span class="pre">f</span> <span class="pre">x</span></code> should have type <code class="docutils literal"><span class="pre">&#8469;</span></code>, and that the resulting expression again has type <code class="docutils literal"><span class="pre">&#8469;</span></code>. In set theory, <span class="math">\(x \in \mathbb{N}\)</span> has to be stated as an explicit hypothesis, and <span class="math">\(f(x) \in \mathbb{N}\)</span> is then a theorem.</li>
<li>By encoding propositions as certain kinds of types, we can use the same language for defining mathematical objects and writing mathematical proofs. For example, we can apply a function to an argument in the same way we apply a theorem to some hypotheses.</li>
<li>Expressions in a sufficiently pure part of dependent type theory have a computational interpretation, so, for example, the logical framework tells us how to evaluate the factorial function, given its definition. In set theory, the computational interpretation is specified independently, after the fact.</li>
</ul>
<p>These facts hark back to the separation of concerns that we raised in <a class="reference internal" href="introduction.html#introduction"><span class="std std-numref">Chapter 1</span></a>: different axiomatic foundations provide different idealized descriptions of mathematical activity, and can be designed to serve different purposes. If you want a clean, simple theory that accounts for the vast majority of mathematical proof, set theory is hard to beat. If you are looking for a foundation that makes computation central or takes the notion of a function rather than a set as basic, various flavors of type theory have their charms. For interactive theorem proving, pragmatic issues regarding implementation and usability come into play. What is important to recognize is that what all these idealized descriptions have in common is that they are all designed to model important aspects of mathematical language and proof. Our goal here has been to help you reflect on those features of mathematical language and proof that give mathematics its special character, and to help you better understand how they work.</p>
</div>
<div class="section" id="exercises">
<h2>23.5. Exercises<a class="headerlink" href="#exercises" title="Permalink to this headline">&#182;</a></h2>
<ol class="arabic simple">
<li>Use an argument similar Russell&#8217;s paradox to show that there is no &#8220;set of all sets,&#8221; that is, there is no set that contains every other set as an element.</li>
<li>Suppose <span class="math">\(x\)</span> is a nonempty set, say, containing an element <span class="math">\(y\)</span>. Use the axiom of separation to show that the set <span class="math">\(\bigcap x\)</span> exists. (Remember that something is an element of <span class="math">\(\bigcap x\)</span> if it is an element of every element of <span class="math">\(x\)</span>.)</li>
<li>Justify the claim in <a class="reference internal" href="#basic-axioms-for-sets"><span class="std std-numref">Section 23.1</span></a> that every element of <span class="math">\(x \times y\)</span> is an element of <span class="math">\(\mathcal P (\mathcal P (x \cup y))\)</span>.</li>
<li>Given a set <span class="math">\(x\)</span> and a function <span class="math">\(A : x \to y\)</span>, use the axioms of set theory to prove the existence of <span class="math">\(\bigcup_{i \in x} A(i)\)</span>.</li>
</ol>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="index.html">Logic and Proof</a></h1>








<!-- <h3>Navigation</h3> -->
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="introduction.html">1. Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="propositional_logic.html">2. Propositional Logic</a></li>
<li class="toctree-l1"><a class="reference internal" href="natural_deduction_for_propositional_logic.html">3. Natural Deduction for Propositional Logic</a></li>
<li class="toctree-l1"><a class="reference internal" href="propositional_logic_in_lean.html">4. Propositional Logic in Lean</a></li>
<li class="toctree-l1"><a class="reference internal" href="classical_reasoning.html">5. Classical Reasoning</a></li>
<li class="toctree-l1"><a class="reference internal" href="semantics_of_propositional_logic.html">6. Semantics of Propositional Logic</a></li>
<li class="toctree-l1"><a class="reference internal" href="first_order_logic.html">7. First Order Logic</a></li>
<li class="toctree-l1"><a class="reference internal" href="natural_deduction_for_first_order_logic.html">8. Natural Deduction for First Order Logic</a></li>
<li class="toctree-l1"><a class="reference internal" href="first_order_logic_in_lean.html">9. First Order Logic in Lean</a></li>
<li class="toctree-l1"><a class="reference internal" href="semantics_of_first_order_logic.html">10. Semantics of First Order Logic</a></li>
<li class="toctree-l1"><a class="reference internal" href="sets.html">11. Sets</a></li>
<li class="toctree-l1"><a class="reference internal" href="sets_in_lean.html">12. Sets in Lean</a></li>
<li class="toctree-l1"><a class="reference internal" href="relations.html">13. Relations</a></li>
<li class="toctree-l1"><a class="reference internal" href="relations_in_lean.html">14. Relations in Lean</a></li>
<li class="toctree-l1"><a class="reference internal" href="functions.html">15. Functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="functions_in_lean.html">16. Functions in Lean</a></li>
<li class="toctree-l1"><a class="reference internal" href="the_natural_numbers_and_induction.html">17. The Natural Numbers and Induction</a></li>
<li class="toctree-l1"><a class="reference internal" href="the_natural_numbers_and_induction_in_lean.html">18. The Natural Numbers and Induction in Lean</a></li>
<li class="toctree-l1"><a class="reference internal" href="elementary_number_theory.html">19. Elementary Number Theory</a></li>
<li class="toctree-l1"><a class="reference internal" href="combinatorics.html">20. Combinatorics</a></li>
<li class="toctree-l1"><a class="reference internal" href="the_real_numbers.html">21. The Real Numbers</a></li>
<li class="toctree-l1"><a class="reference internal" href="the_infinite.html">22. The Infinite</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">23. Axiomatic Foundations</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#basic-axioms-for-sets">23.1. Basic Axioms for Sets</a></li>
<li class="toctree-l2"><a class="reference internal" href="#the-axiom-of-infinity">23.2. The Axiom of Infinity</a></li>
<li class="toctree-l2"><a class="reference internal" href="#the-remaining-axioms">23.3. The Remaining Axioms</a></li>
<li class="toctree-l2"><a class="reference internal" href="#type-theory">23.4. Type Theory</a></li>
<li class="toctree-l2"><a class="reference internal" href="#exercises">23.5. Exercises</a></li>
</ul>
</li>
</ul>


<hr />
<ul>
    
    <li class="toctree-l1"><a href="logic_and_proof.pdf">PDF version</a></li>
    
    <li class="toctree-l1"><a href="https://leanprover.github.io/">Lean Home</a></li>
    
</ul>

<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2017, Jeremy Avigad, Robert Y. Lewis, and Floris van Doorn.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.6.3</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.10</a>
      
      |
      <a href="_sources/axiomatic_foundations.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>