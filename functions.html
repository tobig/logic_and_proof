
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=ascii" />
    <title>15. Functions &#8212; Logic and Proof 0.1 documentation</title>
    <link rel="stylesheet" href="_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '0.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="shortcut icon" href="_static/favicon.ico"/>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="16. Functions in Lean" href="functions_in_lean.html" />
    <link rel="prev" title="14. Relations in Lean" href="relations_in_lean.html" />
<!-- <link href="https://fonts.googleapis.com/css?family=Sorts+Mill+Goudy" rel="stylesheet"> -->
<!-- <link href="https://fonts.googleapis.com/css?family=Average" rel="stylesheet"> -->
<!-- <link href="https://fonts.googleapis.com/css?family=EB+Garamond" rel="stylesheet"> -->

  </head>
  <body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="functions">
<span id="id1"></span><h1>15. Functions<a class="headerlink" href="#functions" title="Permalink to this headline">&#182;</a></h1>
<p>In the late nineteenth century, developments in a number of branches of mathematics pushed towards a uniform treatment of sets, functions, and relations. We have already considered sets and relations. In this chapter, we consider functions and their properties.</p>
<p>A function, <span class="math">\(f\)</span>, is ordinary understood as a mapping from a domain <span class="math">\(X\)</span> to another domain <span class="math">\(Y\)</span>. In set-theoretic foundations, <span class="math">\(X\)</span> and <span class="math">\(Y\)</span> are arbitrary sets. We have seen that in a type-based system like Lean, it is natural to distinguish between types and subsets of a type. In other words, we can consider a type <code class="docutils literal"><span class="pre">X</span></code> of elements, and a set <code class="docutils literal"><span class="pre">A</span></code> of elements of that type. Thus, in the type-theoretic formulation, it is natural to consider functions between types <code class="docutils literal"><span class="pre">X</span></code> and <code class="docutils literal"><span class="pre">Y</span></code>, and consider their behavior with respect to subsets of <code class="docutils literal"><span class="pre">X</span></code> and <code class="docutils literal"><span class="pre">Y</span></code>.</p>
<p>In everyday mathematics, however, set-theoretic language is common, and most mathematicians think of a function as a map between sets. When discussing functions from a mathematical standpoint, therefore, we will also adopt this language, and later switch to the type-theoretic representation when we talk about formalization in Lean.</p>
<div class="section" id="the-function-concept">
<h2>15.1. The Function Concept<a class="headerlink" href="#the-function-concept" title="Permalink to this headline">&#182;</a></h2>
<p>If <span class="math">\(X\)</span> and <span class="math">\(Y\)</span> are any sets, we write <span class="math">\(f : X \to Y\)</span> to express the fact that <span class="math">\(f\)</span> is a function from <span class="math">\(X\)</span> to <span class="math">\(Y\)</span>. This means that <span class="math">\(f\)</span> assigns a value <span class="math">\(f(x)\)</span> in <span class="math">\(Y\)</span> to every element <span class="math">\(x\)</span> of <span class="math">\(X\)</span>. The set <span class="math">\(X\)</span> is called the <em>domain</em> of <span class="math">\(f\)</span>, and the set <span class="math">\(Y\)</span> is called the <em>codomain</em>. (Some authors use the word &#8220;range&#8221; for the codomain, but today it is more common to use the word &#8220;range&#8221; for what we call the <em>image</em> of <span class="math">\(A\)</span> below. We will avoid the ambiguity by avoiding the word range altogether.)</p>
<p>The simplest way to define a function is to give its value at every <span class="math">\(x\)</span> with an explicit expression. For example, we can write any of the following:</p>
<ul>
<li><p class="first">Let <span class="math">\(f : \mathbb{N} \to \mathbb{N}\)</span> be the function defined by <span class="math">\(f(n) = n + 1\)</span>.</p>
</li>
<li><p class="first">Let <span class="math">\(g : \mathbb{R} \to \mathbb{R}\)</span> be the function defined by <span class="math">\(g(x) = x^2\)</span>.</p>
</li>
<li><p class="first">Let <span class="math">\(h : \mathbb{N} \to \mathbb{N}\)</span> be the function defined by <span class="math">\(h(n) = n^2\)</span>.</p>
</li>
<li><p class="first">Let <span class="math">\(k : \mathbb{N} \to \{0, 1\}\)</span> be the function defined by</p>
<div class="math">
\[\begin{split}k(n) =
  \left\{\begin{array}{ll}
    0 &amp; \mbox{if $n$ is even} \\
    1 &amp; \mbox{if $n$ is odd.}
  \end{array}\right.\end{split}\]</div>
</li>
</ul>
<p>The ability to define functions using an explicit expression raises the foundational question as to what counts as legitimate &#8220;expression.&#8221; For the moment, let us set that question aside, and simply note that modern mathematics is comfortable with all kinds of exotic definitions. For example, we can define a function <span class="math">\(f : \mathbb{R} \to \{0, 1\}\)</span> by</p>
<div class="math">
\[\begin{split}f(x) =
  \left\{\begin{array}{ll}
    0 &amp; \mbox{if $x$ is rational} \\
    1 &amp; \mbox{if $x$ is irrational.}
  \end{array}\right.\end{split}\]</div>
<p>This is at odds with a view of functions as objects that are computable in some sense. It is not at all clear what it means to be presented with a real number as input, let alone whether it is possible to determine, algorithmically, whether such a number is rational or not. We will return to such issues in a later chapter.</p>
<p>Notice that the choice of the variables <span class="math">\(x\)</span> and <span class="math">\(n\)</span> in the definitions above are arbitrary. They are bound variables in that the functions being defined do not depend on <span class="math">\(x\)</span> or <span class="math">\(n\)</span>. The values remain the same under renaming, just as the truth values of &#8220;for every <span class="math">\(x\)</span>, <span class="math">\(P(x)\)</span>&#8221; and &#8220;for every <span class="math">\(y\)</span>, <span class="math">\(P(y)\)</span>&#8221; are the same. Given an expression <span class="math">\(e(x)\)</span> that depends on the variable <span class="math">\(x\)</span>, logicians often use the notation <span class="math">\(\lambda x \; e(x)\)</span> to denote the function that maps <span class="math">\(x\)</span> to <span class="math">\(e(x)\)</span>. This is called &#8220;lambda notation,&#8221; for the obvious reason, and it is often quite handy. Instead of saying &#8220;let <span class="math">\(f\)</span> be the function defined by <span class="math">\(f(x) = x+1\)</span>,&#8221; we can say &#8220;let <span class="math">\(f = \lambda \; x (x + 1)\)</span>.&#8221; This is <em>not</em> common mathematical notation, and it is best to avoid it unless you are talking to logicians or computer scientists. We will see, however, that lambda notation is built in to Lean.</p>
<p>For any set <span class="math">\(X\)</span>, we can define a function <span class="math">\(i_X(x)\)</span> by the equation <span class="math">\(i_X(x) = x\)</span>. This function is called the <em>identity function</em>. More interestingly, let <span class="math">\(f : X \to Y\)</span> and <span class="math">\(g : Y \to Z\)</span>. We can define a new function <span class="math">\(k : X \to Z\)</span> by <span class="math">\(k(x) = g(f(x))\)</span>. The function <span class="math">\(k\)</span> is called <em>the composition of</em> <span class="math">\(f\)</span> <em>and</em> <span class="math">\(g\)</span> or <span class="math">\(f\)</span> <em>composed with</em> <span class="math">\(g\)</span> and it is written <span class="math">\(g \circ f\)</span>. The order is somewhat confusing; you just have to keep in mind that to evaluate the expression <span class="math">\(g(f(x))\)</span> you first evaluate <span class="math">\(f\)</span> on input <span class="math">\(x\)</span>, and then evaluate <span class="math">\(g\)</span>.</p>
<p>We think of two functions <span class="math">\(f, g : X \to Y\)</span> as being equal, or the same function, when for they have the same values on every input; in other words, for every <span class="math">\(x\)</span> in <span class="math">\(X\)</span>, <span class="math">\(f(x) = g(x)\)</span>. For example, if <span class="math">\(f, g : \mathbb{R} \to \mathbb{R}\)</span> are defined by <span class="math">\(f(x) = x + 1\)</span> and <span class="math">\(g(x) = 1 + x\)</span>, then <span class="math">\(f = g\)</span>. Notice that the statement that two functions are equal is a universal statement (that is, for the form &#8220;for every <span class="math">\(x\)</span>, &#8230;&#8221;).</p>
<hr class="docutils" />
<p><strong>Proposition.</strong> For every <span class="math">\(f : X \to Y\)</span>, <span class="math">\(f \circ i_X = f\)</span> and <span class="math">\(i_Y \circ f = f\)</span>.</p>
<p><strong>Proof.</strong> Let <span class="math">\(x\)</span> be any element of <span class="math">\(X\)</span>. Then <span class="math">\((f \circ i_X)(x) = f(i_X(x)) = f(x)\)</span>, and <span class="math">\((i_Y \circ f)(x) = i_Y(f(x)) = x\)</span>.</p>
<hr class="docutils" />
<p>Suppose <span class="math">\(f : X \to Y\)</span> and <span class="math">\(g : Y \to X\)</span> satisfy <span class="math">\(g \circ f = i_X\)</span>. Remember that this means that <span class="math">\(g(f(x)) = x\)</span> for every <span class="math">\(x\)</span> in <span class="math">\(X\)</span>. In that case, <span class="math">\(g\)</span> is said to be a <em>left inverse</em> to <span class="math">\(f\)</span>, and <span class="math">\(f\)</span> is said to be a <em>right inverse</em> to <span class="math">\(g\)</span>. Here are some examples:</p>
<ul class="simple">
<li>Define <span class="math">\(f, g : \mathbb{R} \to \mathbb{R}\)</span> by <span class="math">\(f(x) = x + 1\)</span> and <span class="math">\(g(x) = x - 1\)</span>. Then <span class="math">\(g\)</span> is both a left and a right inverse to <span class="math">\(f\)</span>, and vice-versa.</li>
<li>Write <span class="math">\(\mathbb{R}^{\geq 0}\)</span> to denote the nonnegative reals. Define <span class="math">\(f : \mathbb{R} \to \mathbb{R}^{\geq 0}\)</span> by <span class="math">\(f(x) = x^2\)</span>, and define <span class="math">\(g : \mathbb{R}^{\geq 0} \to \mathbb{R}\)</span> by <span class="math">\(g(x) = \sqrt x\)</span>. Then <span class="math">\(f(g(x)) = (\sqrt x)^2 = x\)</span> for every <span class="math">\(x\)</span> in the domain of <span class="math">\(g\)</span>, so <span class="math">\(f\)</span> is a left inverse to <span class="math">\(g\)</span>, and <span class="math">\(g\)</span> is a right inverse to <span class="math">\(f\)</span>. On the other hand, <span class="math">\(g(f(x)) = \sqrt{x^2} = | x |\)</span>, which is not the same as <span class="math">\(x\)</span> when <span class="math">\(x\)</span> is negative. So <span class="math">\(g\)</span> is not a left inverse to <span class="math">\(f\)</span>, and <span class="math">\(f\)</span> is not a right inverse to <span class="math">\(g\)</span>.</li>
</ul>
<p>The following fact is not at all obvious, even though the proof is short:</p>
<hr class="docutils" />
<p><strong>Proposition.</strong> Suppose <span class="math">\(f : X \to Y\)</span> has a left inverse, <span class="math">\(h\)</span>, and a right inverse, <span class="math">\(k\)</span>. Then <span class="math">\(h = k\)</span>.</p>
<p><strong>Proof.</strong> Let <span class="math">\(y\)</span> be any element in <span class="math">\(Y\)</span>. The idea is to compute <span class="math">\(h(f(k(y))\)</span> in two different ways. Since <span class="math">\(h\)</span> is a left inverse to <span class="math">\(f\)</span>, we have <span class="math">\(h(f(k(y))) = k(y)\)</span>. On the other hand, since <span class="math">\(k\)</span> is a right inverse to <span class="math">\(f\)</span>, <span class="math">\(f(k(y)) = y\)</span>, and so <span class="math">\(h(f(k(y)) = h(y)\)</span>. So <span class="math">\(k(y) = h(y)\)</span>.</p>
<hr class="docutils" />
<p>If <span class="math">\(g\)</span> is both a right and left inverse to <span class="math">\(f\)</span>, we say that <span class="math">\(g\)</span> is simply the inverse of <span class="math">\(f\)</span>. A function <span class="math">\(f\)</span> may have more than one left or right inverse (we leave it to you to cook up examples), but it can have at most one inverse.</p>
<hr class="docutils" />
<p><strong>Proposition.</strong> Suppose <span class="math">\(g_1, g_2 : Y \to X\)</span> are both inverses to <span class="math">\(f\)</span>. Then <span class="math">\(g_1 = g_2\)</span>.</p>
<p><strong>Proof.</strong> This follows from the previous proposition, since (say) <span class="math">\(g_1\)</span> is a left inverse to <span class="math">\(f\)</span>, and <span class="math">\(g_2\)</span> is a right inverse.</p>
<hr class="docutils" />
<p>When <span class="math">\(f\)</span> has an inverse, <span class="math">\(g\)</span>, this justifies calling <span class="math">\(g\)</span> <em>the</em> inverse to <span class="math">\(f\)</span>, and writing <span class="math">\(f^{-1}\)</span> to denote <span class="math">\(g\)</span>. Notice that if <span class="math">\(f^{-1}\)</span> is an inverse to <span class="math">\(f\)</span>, then <span class="math">\(f\)</span> is an inverse to <span class="math">\(f^{-1}\)</span>. So if <span class="math">\(f\)</span> has an inverse, then so does <span class="math">\(f^{-1}\)</span>, and <span class="math">\((f^{-1})^{-1} = f\)</span>. For any set <span class="math">\(A\)</span>, clearly we have <span class="math">\(i_X^{-1} = i_X\)</span>.</p>
<hr class="docutils" />
<p><strong>Proposition.</strong> Suppose <span class="math">\(f : X \to Y\)</span> and <span class="math">\(g : Y \to Z\)</span>. If <span class="math">\(h : Y \to X\)</span> is a left inverse to <span class="math">\(f\)</span> and <span class="math">\(k : Z \to Y\)</span> is a left inverse to <span class="math">\(g\)</span>, then <span class="math">\(h \circ k\)</span> is a left inverse to <span class="math">\(g \circ f\)</span>.</p>
<p><strong>Proof.</strong> For every <span class="math">\(x\)</span> in <span class="math">\(X\)</span>,</p>
<div class="math">
\[(h \circ k) \circ (g \circ f) (x) = h(k(g(f(x)))) = h(f(x)) = x.\]</div>
<p><strong>Corollary.</strong> The previous proposition holds with &#8220;left&#8221; replaced by &#8220;right.&#8221;</p>
<p><strong>Proof.</strong> Switch the role of <span class="math">\(f\)</span> with <span class="math">\(h\)</span> and <span class="math">\(g\)</span> with <span class="math">\(k\)</span> in the previous proposition.</p>
<p><strong>Corollary.</strong> If <span class="math">\(f : X \to Y\)</span> and <span class="math">\(g : Y \to Z\)</span> both have inverses, then <span class="math">\((f \circ g)^{-1} = g^{-1} \circ f^{-1}\)</span>.</p>
<hr class="docutils" />
</div>
<div class="section" id="injective-surjective-and-bijective-functions">
<span id="id2"></span><h2>15.2. Injective, Surjective, and Bijective Functions<a class="headerlink" href="#injective-surjective-and-bijective-functions" title="Permalink to this headline">&#182;</a></h2>
<p>A function <span class="math">\(f : X \to Y\)</span> is said to be <em>injective</em>, or an <em>injection</em>, or <em>one-one</em>, if given any <span class="math">\(x_1\)</span> and <span class="math">\(x_2\)</span> in <span class="math">\(A\)</span>, if <span class="math">\(f(x_1) = f(x_2)\)</span>, then <span class="math">\(x_1 = x_2\)</span>. Notice that the conclusion is equivalent to its contrapositive: if <span class="math">\(x_1 \neq x_2\)</span>, then <span class="math">\(f(x_1) \neq f(x_2)\)</span>. So <span class="math">\(f\)</span> is injective if it maps distinct element of <span class="math">\(X\)</span> to distinct elements of <span class="math">\(Y\)</span>.</p>
<p>A function <span class="math">\(f : X \to Y\)</span> is said to be <em>surjective</em>, or a <em>surjection</em>, or <em>onto</em>, if for every element <span class="math">\(y\)</span> of <span class="math">\(Y\)</span>, there is an <span class="math">\(x\)</span> in <span class="math">\(X\)</span> such that <span class="math">\(f(x) = y\)</span>. In other words, <span class="math">\(f\)</span> is surjective if every element in the codomain is the value of <span class="math">\(f\)</span> at some element in the domain.</p>
<p>A function <span class="math">\(f : X \to Y\)</span> is said to be <em>bijective</em>, or a <em>bijection</em>, or a <em>one-to-one correspondence</em>, if it is both injective and surjective. Intuitively, if there is a bijection between <span class="math">\(X\)</span> and <span class="math">\(Y\)</span>, then <span class="math">\(X\)</span> and <span class="math">\(Y\)</span> have the same size, since <span class="math">\(f\)</span> makes each element of <span class="math">\(X\)</span> correspond to exactly one element of <span class="math">\(Y\)</span> and vice-versa. For example, it makes sense to interpret the statement that there were four Beatles as the statement that there is a bijection between the set <span class="math">\(\{1, 2, 3, 4\}\)</span> and the set <span class="math">\(\{ \text{John, Paul, George, Ringo} \}\)</span>. If we claimed that there were <em>five</em> Beatles, as evidenced by the function <span class="math">\(f\)</span> which assigns 1 to John, 2 to Paul, 3 to George, 4 to Ringo, and 5 to John, you should object that we double-counted John&#8212;that is, <span class="math">\(f\)</span> is not injective. If we claimed there were only three Beatles, as evidenced by the function <span class="math">\(f\)</span> which assigns 1 to John, 2 to Paul, and 3 to George, you should object that we left out poor Ringo&#8212;that is, <span class="math">\(f\)</span> is not surjective.</p>
<p>The next two propositions show that these notions can be cast in terms of the existence of inverses.</p>
<hr class="docutils" />
<p><strong>Proposition.</strong> Let <span class="math">\(f : X \to Y\)</span>.</p>
<ul class="simple">
<li>If <span class="math">\(f\)</span> has a left inverse, then <span class="math">\(f\)</span> is injective.</li>
<li>If <span class="math">\(f\)</span> has a right inverse, then <span class="math">\(f\)</span> is surjective.</li>
<li>If <span class="math">\(f\)</span> has an inverse, then it is <span class="math">\(f\)</span> bijective.</li>
</ul>
<p><strong>Proof.</strong> For the first claim, suppose <span class="math">\(f\)</span> has a left inverse <span class="math">\(g\)</span>, and suppose <span class="math">\(f(x_1) = f(x_2)\)</span>. Then <span class="math">\(g(f(x_1)) = g(f(x_2))\)</span>, and so <span class="math">\(x_1 = x_2\)</span>.</p>
<p>For the second claim, suppose <span class="math">\(f\)</span> has a right inverse <span class="math">\(h\)</span>. Let <span class="math">\(y\)</span> be any element of <span class="math">\(Y\)</span>, and let <span class="math">\(x = g(y)\)</span>. Then <span class="math">\(f(x) = f(g(y)) = y\)</span>.</p>
<p>The third claim follows from the first two.</p>
<hr class="docutils" />
<p>The following proposition is more interesting, because it requires us to define new functions, given hypotheses on <span class="math">\(f\)</span>.</p>
<hr class="docutils" />
<p><strong>Proposition.</strong> Let <span class="math">\(f : X \to Y\)</span>.</p>
<ul class="simple">
<li>If <span class="math">\(X\)</span> is nonempty and <span class="math">\(f\)</span> is injective, then <span class="math">\(f\)</span> has a left inverse.</li>
<li>If <span class="math">\(f\)</span> is surjective, then <span class="math">\(f\)</span> has a right inverse.</li>
<li>If <span class="math">\(f\)</span> if bijective, then it has an inverse.</li>
</ul>
<p><strong>Proof.</strong> For the first claim, let <span class="math">\(\hat x\)</span> be any element of <span class="math">\(X\)</span>, and suppose <span class="math">\(f\)</span> is injective. Define <span class="math">\(g : Y \to X\)</span> by setting <span class="math">\(g(y)\)</span> equal to any <span class="math">\(x\)</span> such that <span class="math">\(f(x) = y\)</span>, if there is one, and <span class="math">\(\hat x\)</span> otherwise. Now, suppose <span class="math">\(g(f(x)) = x'\)</span>. By the definition of <span class="math">\(g\)</span>, <span class="math">\(x'\)</span> has to have the property that <span class="math">\(f(x) = f(x')\)</span>. Since <span class="math">\(f\)</span> is injective, <span class="math">\(x = x'\)</span>, so <span class="math">\(g(f(x)) = x\)</span>.</p>
<p>For the second claim, because <span class="math">\(f\)</span> is surjective, we know that for every <span class="math">\(y\)</span> in <span class="math">\(Y\)</span> there is any <span class="math">\(x\)</span> such that <span class="math">\(f(x) = y\)</span>. Define <span class="math">\(h : B \to A\)</span> by again setting <span class="math">\(h(y)\)</span> equal to any such <span class="math">\(x\)</span>. (In contrast to the previous paragraph, here we know that such an <span class="math">\(x\)</span> exists, but it might not be unique.) Then, by the definition of <span class="math">\(h\)</span>, we have <span class="math">\(f(h(y)) = y\)</span>.</p>
<hr class="docutils" />
<p>Notice that the definition of <span class="math">\(g\)</span> in the first part of the proof requires the function to &#8220;decide&#8221; whether there is an <span class="math">\(x\)</span> in <span class="math">\(X\)</span> such that <span class="math">\(f(x) = y\)</span>. There is nothing mathematically dubious about this definition, but in many situations, this cannot be done <em>algorithmically</em>; in other words, <span class="math">\(g\)</span> might not be computable from the data. More interestingly, the definition of <span class="math">\(h\)</span> in the second part of the proof requires the function to &#8220;choose&#8221; a suitable value of <span class="math">\(x\)</span> from among potentially many candidates. We will see in <a class="reference internal" href="axiomatic_foundations.html#the-remaining-axioms"><span class="std std-numref">Section 23.3</span></a> that this is a version of the <em>axiom of choice</em>. In the early twentieth century, the use of the axiom of choice in mathematics was hotly debated, but today it is commonplace.</p>
<p>Using these equivalences and the results in the previous section, we can prove the following:</p>
<hr class="docutils" />
<p><strong>Proposition.</strong> Let <span class="math">\(f : X \to B\)</span> and <span class="math">\(g : Y \to Z\)</span>.</p>
<ul class="simple">
<li>If <span class="math">\(f\)</span> and <span class="math">\(g\)</span> are injective, then so is <span class="math">\(g \circ f\)</span>.</li>
<li>If <span class="math">\(f\)</span> and <span class="math">\(g\)</span> are surjective, then so is <span class="math">\(g \circ f\)</span>.</li>
</ul>
<p><strong>Proof.</strong> If <span class="math">\(f\)</span> and <span class="math">\(g\)</span> are injective, then they have left inverses <span class="math">\(h\)</span> and <span class="math">\(k\)</span>, respectively, in which case <span class="math">\(h \circ k\)</span> is a left inverse to <span class="math">\(g \circ f\)</span>. The second statement is proved similarly.</p>
<hr class="docutils" />
<p>We can prove these two statements, however, without mentioning inverses at all. We leave that to you as an exercise.</p>
<p>Notice that the expression <span class="math">\(f(n) = 2 n\)</span> can be used to define infinitely many functions with domain <span class="math">\(\mathbb{N}\)</span>, such as:</p>
<ul class="simple">
<li>a function <span class="math">\(f : \mathbb{N} \to \mathbb{N}\)</span></li>
<li>a function <span class="math">\(f : \mathbb{N} \to \mathbb{R}\)</span></li>
<li>a function <span class="math">\(f: \mathbb{N} \to \{ n \mid n \text{ is even} \}\)</span></li>
</ul>
<p>Only the third one is surjective. Thus a specification of the function&#8217;s codomain as well as the domain is essential to making sense of whether a function is surjective.</p>
</div>
<div class="section" id="functions-and-subsets-of-the-domain">
<h2>15.3. Functions and Subsets of the Domain<a class="headerlink" href="#functions-and-subsets-of-the-domain" title="Permalink to this headline">&#182;</a></h2>
<p>Suppose <span class="math">\(f\)</span> is a function from <span class="math">\(X\)</span> to <span class="math">\(Y\)</span>. We may wish to reason about the behavior of <span class="math">\(f\)</span> on some subset <span class="math">\(A\)</span> of <span class="math">\(X\)</span>. For example, we can say that <span class="math">\(f\)</span> <em>is injective on</em> <span class="math">\(A\)</span> if for every <span class="math">\(x_1\)</span> and <span class="math">\(x_2\)</span> in <span class="math">\(A\)</span>, if <span class="math">\(f(x_1) = f(x_2)\)</span>, then <span class="math">\(x_1 = x_2\)</span>.</p>
<p>If <span class="math">\(f\)</span> is a function from <span class="math">\(X\)</span> to <span class="math">\(Y\)</span> and <span class="math">\(A\)</span> is a subset of <span class="math">\(X\)</span>, we write <span class="math">\(f[A]\)</span> to denote the <em>image of</em> <span class="math">\(f\)</span> <em>on</em> <span class="math">\(A\)</span>, defined by</p>
<div class="math">
\[f[A] = \{ y \in Y \mid y = f(x) \; \mbox{for some $x$ in $A$} \}.\]</div>
<p>In words, <span class="math">\(f[A]\)</span> is the set of elements of <span class="math">\(Y\)</span> that are &#8220;hit&#8221; by elements of <span class="math">\(A\)</span> under the mapping <span class="math">\(f\)</span>. Notice that there is an implicit existential quantifier here, so that reasoning about images invariably involves the corresponding rules.</p>
<hr class="docutils" />
<p><strong>Proposition.</strong> Suppose <span class="math">\(f : X \to Y\)</span>, and <span class="math">\(A\)</span> is a subset of <span class="math">\(X\)</span>. Then for any <span class="math">\(x\)</span> in <span class="math">\(A\)</span>, <span class="math">\(f(x)\)</span> is in <span class="math">\(f[A]\)</span>.</p>
<p><strong>Proof.</strong> By definition, <span class="math">\(f(x)\)</span> is in <span class="math">\(f[A]\)</span> if and only if there is some <span class="math">\(x'\)</span> in <span class="math">\(A\)</span> such that <span class="math">\(f(x') = f(x)\)</span>. But that holds for <span class="math">\(x' = x\)</span>.</p>
<p><strong>Proposition.</strong> Suppose <span class="math">\(f : X \to Y\)</span> and <span class="math">\(g : Y \to Z\)</span>. Let <span class="math">\(A\)</span> be a subset of <span class="math">\(X\)</span>. Then</p>
<div class="math">
\[(g \circ f)[A] = g[f[A]].\]</div>
<p><strong>Proof.</strong> Suppose <span class="math">\(z\)</span> is in <span class="math">\((g \circ f)[A]\)</span>. Then for some <span class="math">\(x \in A\)</span>, <span class="math">\(z = (g \circ f)(x) = g(f(x))\)</span>. By the previous proposition, <span class="math">\(f(x)\)</span> is in <span class="math">\(f[A]\)</span>. Again by the previous proposition, <span class="math">\(g(f(x))\)</span> is in <span class="math">\(g[f[A]]\)</span>.</p>
<p>Conversely, suppose <span class="math">\(z\)</span> is in <span class="math">\(g[f[A]]\)</span>. Then there is a <span class="math">\(y\)</span> in <span class="math">\(f[A]\)</span> such that <span class="math">\(f(y) = z\)</span>, and since <span class="math">\(y\)</span> is in <span class="math">\(f[D]\)</span>, there is an <span class="math">\(x\)</span> in <span class="math">\(A\)</span> such that <span class="math">\(f(x) = y\)</span>. But then <span class="math">\((g \circ f)(x) = g(f(x)) = g(y) = z\)</span>, so <span class="math">\(z\)</span> is in <span class="math">\((g \circ f)[A]\)</span>.</p>
<hr class="docutils" />
<p>Notice that if <span class="math">\(f\)</span> is a function from <span class="math">\(X\)</span> to <span class="math">\(Y\)</span>, then <span class="math">\(f\)</span> is surjective if and only if <span class="math">\(f[X] = Y\)</span>. So the previous proposition is a generalization of the fact that the composition of surjective functions is surjective.</p>
<p>Suppose <span class="math">\(f\)</span> is a function from <span class="math">\(X\)</span> to <span class="math">\(Y\)</span>, and <span class="math">\(A\)</span> is a subset of <span class="math">\(X\)</span>. We can <em>view</em> <span class="math">\(f\)</span> as a function from <span class="math">\(A\)</span> to <span class="math">\(Y\)</span>, by simply ignoring the behavior of <span class="math">\(f\)</span> on elements outside of <span class="math">\(A\)</span>. Properly speaking, this is another function, denoted <span class="math">\(f \upharpoonright A\)</span> and called &#8220;the restriction of <span class="math">\(f\)</span> to <span class="math">\(A\)</span>.&#8221; In other words, given <span class="math">\(f : X \to Y\)</span> and <span class="math">\(A \subseteq X\)</span>, <span class="math">\(f \upharpoonright A : A \to Y\)</span> is the function defined by <span class="math">\((f \upharpoonright A)(x) = x\)</span> for every <span class="math">\(x\)</span> in <span class="math">\(A\)</span>. Notice that now &#8220;<span class="math">\(f\)</span> is injective on <span class="math">\(A\)</span>&#8221; means simply that the restriction of <span class="math">\(f\)</span> to <span class="math">\(A\)</span> is injective.</p>
<p>There is another important operation on functions, known as the <em>preimage</em>. If <span class="math">\(f : X \to Y\)</span> and <span class="math">\(B \subseteq Y\)</span>, then the <em>preimage of</em> <span class="math">\(B\)</span> <em>under</em> <span class="math">\(f\)</span>, denoted <span class="math">\(f^{-1}[B]\)</span>, is defined by</p>
<div class="math">
\[f^{-1}[B] = \{ x \in X \mid f(x) \in B \},\]</div>
<p>that is, the set of elements of <span class="math">\(X\)</span> that get mapped into <span class="math">\(B\)</span>. Notice that this makes sense even if <span class="math">\(f\)</span> does not have an inverse; for a given <span class="math">\(y\)</span> in <span class="math">\(B\)</span>, there may be no <span class="math">\(x\)</span>&#8216;s with the property <span class="math">\(f(x) \in B\)</span>, or there may be many. If <span class="math">\(f\)</span> has an inverse, <span class="math">\(f^{-1}\)</span>, then for every <span class="math">\(y\)</span> in <span class="math">\(B\)</span> there is exactly one <span class="math">\(x \in X\)</span> with the property <span class="math">\(f(x) \in B\)</span>, in which case, <span class="math">\(f^{-1}[B]\)</span> means the same thing whether you interpret it as the image of <span class="math">\(B\)</span> under <span class="math">\(f^{-1}\)</span> or the preimage of <span class="math">\(B\)</span> under <span class="math">\(f\)</span>.</p>
<hr class="docutils" />
<p><strong>Proposition.</strong> Suppose <span class="math">\(f : X \to Y\)</span> and <span class="math">\(g : Y \to Z\)</span>. Let <span class="math">\(C\)</span> be a subset of <span class="math">\(Z\)</span>. Then</p>
<div class="math">
\[(g \circ f)^{-1}[C] = f^{-1}[g^{-1}[C]].\]</div>
<p><strong>Proof.</strong> For any <span class="math">\(y\)</span> in <span class="math">\(C\)</span>, <span class="math">\(y\)</span> is in <span class="math">\((g \circ f)^{-1}[C]\)</span> if and only if <span class="math">\(g(f(y))\)</span> is in <span class="math">\(C\)</span>. This, in turn, happens if and only if <span class="math">\(f(y)\)</span> is in <span class="math">\(g^{-1}[C]\)</span>, which in turn happens if and only if <span class="math">\(y\)</span> is in <span class="math">\(f^{-1}[g^{-1}[C]]\)</span>.</p>
<hr class="docutils" />
<p>Here we give a long list of facts properties of images and preimages. Here, <span class="math">\(f\)</span> denotes an arbitrary function from <span class="math">\(X\)</span> to <span class="math">\(Y\)</span>, <span class="math">\(A, A_1, A_2, \ldots\)</span> denote arbitrary subsets of <span class="math">\(X\)</span>, and <span class="math">\(B, B_1, B_2, \ldots\)</span> denote arbitrary subsets of <span class="math">\(Y\)</span>.</p>
<ul class="simple">
<li><span class="math">\(A \subseteq f^{-1}[f[A]]\)</span>, and if <span class="math">\(f\)</span> is injective, <span class="math">\(A = f^{-1}[f[A]]\)</span>.</li>
<li><span class="math">\(f[f^{-1}[B]] \subseteq B\)</span>, and if <span class="math">\(f\)</span> is surjective, <span class="math">\(B = f[f^{-1}[B]]\)</span>.</li>
<li>If <span class="math">\(A_1 \subseteq A_2\)</span>, then <span class="math">\(f[A_1] \subseteq f[A_2]\)</span>.</li>
<li>If <span class="math">\(B_1 \subseteq B_2\)</span>, then <span class="math">\(f^{-1}[B_1] \subseteq f^{-1}[B_2]\)</span>.</li>
<li><span class="math">\(f[A_1 \cup A_2] = f[A_1] \cup f[A_2]\)</span>.</li>
<li><span class="math">\(f^{-1}[B_1 \cup B_2] = f^{-1}[B_1] \cup f^{-1}[B_2]\)</span>.</li>
<li><span class="math">\(f[A_1 \cap A_2] \subseteq f[A_1] \cap f[A_2]\)</span>, and if <span class="math">\(f\)</span> is injective, <span class="math">\(f[A_1 \cap A_2] = f[A_1] \cap f[A_2]\)</span>.</li>
<li><span class="math">\(f^{-1}[B_1 \cap B_2] = f^{-1}[B_1] \cap f^{-1}[B_2]\)</span>.</li>
<li><span class="math">\(f[A] \setminus f[B] \subseteq f[A \setminus B]\)</span>.</li>
<li><span class="math">\(f^{-1}[A] \setminus f^{-1}[B] \subseteq f[A \setminus B]\)</span>.</li>
<li><span class="math">\(f[A] \cap B = f[A \cap f^{-1}[B]]\)</span>.</li>
<li><span class="math">\(f[A] \cup B \supseteq f[A \cup f^{-1}[B]]\)</span>.</li>
<li><span class="math">\(A \cap f^{-1}[B] \subseteq f^{-1}[f[A] \cap B]\)</span>.</li>
<li><span class="math">\(A \cup f^{-1}[B] \subseteq f^{-1}[f[A] \cup B]\)</span>.</li>
</ul>
<p>Proving identities like this is typically a matter of unfolding definitions and using basic logical inferences. Here is an example.</p>
<hr class="docutils" />
<p><strong>Proposition.</strong> Let <span class="math">\(X\)</span> and <span class="math">\(Y\)</span> be sets, <span class="math">\(f : X \to Y\)</span>, <span class="math">\(A \subseteq X\)</span>, and <span class="math">\(B \subseteq Y\)</span>. Then <span class="math">\(f[A] \cap B = f[A \cap f^{-1}[B]]\)</span>.</p>
<p><strong>Proof.</strong> Suppose <span class="math">\(y \in f[A] \cap B\)</span>. Then <span class="math">\(y \in B\)</span>, and for some <span class="math">\(x \in A\)</span>, <span class="math">\(f(x) = y\)</span>. But this means that <span class="math">\(x\)</span> is in <span class="math">\(f^{-1}[B]\)</span>, and so <span class="math">\(x \in A \cap f^{-1}[B]\)</span>. Since <span class="math">\(f(x) = y\)</span>, we have <span class="math">\(y \in f[A \cap f^{-1}[B]]\)</span>, as needed.</p>
<p>Conversely, suppose <span class="math">\(y \in f[A \cap f^{-1}[B]]\)</span>. Then for some <span class="math">\(x \in A \cap f^{-1}[B]\)</span>, we have <span class="math">\(f(x) = y\)</span>. For this <span class="math">\(x\)</span>, have <span class="math">\(x \in A\)</span> and <span class="math">\(f(x) \in B\)</span>. Since <span class="math">\(f(x) = y\)</span>, we have <span class="math">\(y \in B\)</span>, and since <span class="math">\(x \in A\)</span>, we also have <span class="math">\(y \in f[A]\)</span>, as required.</p>
<hr class="docutils" />
</div>
<div class="section" id="functions-and-relations">
<span id="id3"></span><h2>15.4. Functions and Relations<a class="headerlink" href="#functions-and-relations" title="Permalink to this headline">&#182;</a></h2>
<p>A binary relation <span class="math">\(R(x,y)\)</span> on <span class="math">\(A\)</span> and <span class="math">\(B\)</span> is <em>functional</em> if for every <span class="math">\(x\)</span> in <span class="math">\(A\)</span> there exists a unique <span class="math">\(y\)</span> in <span class="math">\(B\)</span> such that <span class="math">\(R(x,y)\)</span>. If <span class="math">\(R\)</span> is a functional relation, we can define a function <span class="math">\(f_R : X \to B\)</span> by setting <span class="math">\(f_R(x)\)</span> to be equal to the unique <span class="math">\(y\)</span> in <span class="math">\(B\)</span> such that <span class="math">\(R(x,y)\)</span>. Conversely, it is not hard to see that if <span class="math">\(f : X \to B\)</span> is any function, the relation <span class="math">\(R_f(x, y)\)</span> defined by <span class="math">\(f(x) = y\)</span> is a functional relation. The relation <span class="math">\(R_f(x,y)\)</span> is known as the <em>graph</em> of <span class="math">\(f\)</span>.</p>
<p>It is not hard to check that functions and relations travel in pairs: if <span class="math">\(f\)</span> is the function associated with a functional relation <span class="math">\(R\)</span>, then <span class="math">\(R\)</span> is the functional relation associated the function <span class="math">\(f\)</span>, and vice-versa. In set-theoretic foundations, a function is often defined to be a functional relation. Conversely, we have seen that in type-theoretic foundations like the one adopted by Lean, relations are often defined to be certain types of functions. We will discuss these matters later on, and in the meanwhile only remark that in everyday mathematical practice, the foundational details are not so important; what is important is simply that every function has a graph, and that any functional relation can be used to define a corresponding function.</p>
<p>So far, we have been focusing on functions that take a single argument. We can also consider functions <span class="math">\(f(x, y)\)</span> or <span class="math">\(g(x, y, z)\)</span> that take multiple arguments. For example, the addition function <span class="math">\(f(x, y) = x + y\)</span> on the integers takes two integers and returns an integer. Remember, we can consider binary functions, ternary functions, and so on, and the number of arguments to a function is called its &#8220;arity.&#8221; One easy way to make sense of functions with multiple arguments is to think of them as unary functions from a cartesian product. We can think of a function <span class="math">\(f\)</span> which takes two arguments, one in <span class="math">\(A\)</span> and one in <span class="math">\(B\)</span>, and returns an argument in <span class="math">\(C\)</span> as a unary function from <span class="math">\(A \times B\)</span> to <span class="math">\(C\)</span>, whereby <span class="math">\(f(a, b)\)</span> abbreviates <span class="math">\(f((a, b))\)</span>. We have seen that in dependent type theory (and in Lean) it is more convenient to think of such a function <span class="math">\(f\)</span> as a function which takes an element of <span class="math">\(A\)</span> and returns a function from <span class="math">\(B \to C\)</span>, so that <span class="math">\(f(a, b)\)</span> abbreviates <span class="math">\((f(a))(b)\)</span>. Such a function <span class="math">\(f\)</span> maps <span class="math">\(A\)</span> to <span class="math">\(B \to C\)</span>, where <span class="math">\(B \to C\)</span> is the set of functions from <span class="math">\(B\)</span> to <span class="math">\(C\)</span>.</p>
<p>We will return to these different ways of modeling functions of higher arity later on, when we consider set-theoretic and type-theoretic foundations. One again, we remark that in ordinary mathematics, the foundational details do not matter much. The two choices above are inter-translatable, and sanction the same principles for reasoning about functions informally.</p>
<p>In mathematics, we often also consider the notion of a <em>partial function</em> from <span class="math">\(X\)</span> to <span class="math">\(Y\)</span>, which is really a function from some subset of <span class="math">\(X\)</span> to <span class="math">\(Y\)</span>. The fact that <span class="math">\(f\)</span> is a partial function from <span class="math">\(X\)</span> to <span class="math">\(Y\)</span> is sometimes written <span class="math">\(f : X \nrightarrow Y\)</span>, which should be interpreted as saying that <span class="math">\(f : A \to Y\)</span> for some subset <span class="math">\(A\)</span> of <span class="math">\(Y\)</span>. Intuitively, we think of <span class="math">\(f\)</span> as a function from <span class="math">\(X \to Y\)</span> which is simply &#8220;undefined&#8221; at some of its inputs; for example, we can think of <span class="math">\(f : \mathbb{R} \nrightarrow \mathbb{R}\)</span> defined by <span class="math">\(f(x) = 1 / x\)</span>, which is undefined at <span class="math">\(x = 0\)</span>, so that in reality <span class="math">\(f : \mathbb{R} \setminus \{ 0 \} \to R\)</span>. The set <span class="math">\(A\)</span> is sometimes called the <em>domain of</em> <span class="math">\(f\)</span>, in which case, there is no good name for <span class="math">\(X\)</span>; others continue to call <span class="math">\(X\)</span> the domain, and refer to <span class="math">\(A\)</span> as the <em>domain of definition</em>. To indicate that a function <span class="math">\(f\)</span> is defined at <span class="math">\(x\)</span>, that is, that <span class="math">\(x\)</span> is in the domain of definition of <span class="math">\(f\)</span>, we sometimes write <span class="math">\(f(x) \downarrow\)</span>. If <span class="math">\(f\)</span> and <span class="math">\(g\)</span> are two partial functions from <span class="math">\(X\)</span> to <span class="math">\(Y\)</span>, we write <span class="math">\(f(x) \simeq g(x)\)</span> to mean that either <span class="math">\(f\)</span> and <span class="math">\(g\)</span> are both defined at <span class="math">\(x\)</span> and have the same value, or are both undefined at <span class="math">\(x\)</span>. Notions of injectivity, surjectivity, and composition are extended to partial functions, generally as you would expect them to be.</p>
<p>In terms of relations, a partial function <span class="math">\(f\)</span> corresponds to a relation <span class="math">\(R_f(x,y)\)</span> such that for every <span class="math">\(x\)</span> there is at most one <span class="math">\(y\)</span> such that <span class="math">\(R_f(x,y)\)</span> holds. Mathematicians also sometimes consider <em>multifunctions</em> from <span class="math">\(X\)</span> to <span class="math">\(Y\)</span>, which correspond to relations <span class="math">\(R_f(x,y)\)</span> such that for every <span class="math">\(x\)</span> in <span class="math">\(X\)</span>, there is <em>at least</em> one <span class="math">\(y\)</span> such that <span class="math">\(R_f(x,y)\)</span> holds. There may be many such <span class="math">\(y\)</span>; you can think of these as functions which have more than one output value. If you think about it for a moment, you will see that a <em>partial multifunction</em> is essentially nothing more than an arbitrary relation.</p>
</div>
<div class="section" id="exercises">
<h2>15.5. Exercises<a class="headerlink" href="#exercises" title="Permalink to this headline">&#182;</a></h2>
<ol class="arabic simple">
<li>Let <span class="math">\(f\)</span> be any function from <span class="math">\(X\)</span> to <span class="math">\(Y\)</span>, and let <span class="math">\(g\)</span> be any function from <span class="math">\(Y\)</span> to <span class="math">\(Z\)</span>.<ul>
<li>Show that if <span class="math">\(g \circ f\)</span> is injective, then <span class="math">\(f\)</span> is injective.</li>
<li>Give an example of functions <span class="math">\(f\)</span> and <span class="math">\(g\)</span> as above, such that that <span class="math">\(g \circ f\)</span> is injective, but <span class="math">\(g\)</span> is not injective.</li>
<li>Show that if <span class="math">\(g \circ f\)</span> is injective and <span class="math">\(f\)</span> is surjective, then <span class="math">\(g\)</span> is injective.</li>
</ul>
</li>
<li>Let <span class="math">\(f\)</span> and <span class="math">\(g\)</span> be as in the last problem. Suppose <span class="math">\(g \circ f\)</span> is surjective.<ul>
<li>Is <span class="math">\(f\)</span> necessarily surjective? Either prove that it is, or give a counterexample.</li>
<li>Is <span class="math">\(g\)</span> necessarily surjective? Either prove that it is, or give a counterexample.</li>
</ul>
</li>
<li>A function <span class="math">\(f\)</span> from <span class="math">\(\mathbb{R}\)</span> to <span class="math">\(\mathbb{R}\)</span> is said to be
<em>strictly increasing</em> if whenever <span class="math">\(x_1 &lt; x_2\)</span>, <span class="math">\(f(x_1) &lt; f(x_2)\)</span>.<ul>
<li>Show that if <span class="math">\(f : \mathbb{R} \to \mathbb{R}\)</span> is strictly increasing, then it is injective (and hence it has a left inverse).</li>
<li>Show that if <span class="math">\(f : \mathbb{R} \to \mathbb{R}\)</span> is strictly increasing, and <span class="math">\(g\)</span> is a right inverse to <span class="math">\(f\)</span>, then <span class="math">\(g\)</span> is
strictly increasing.</li>
</ul>
</li>
<li>Let <span class="math">\(f : X \to Y\)</span> be any function, and let <span class="math">\(A\)</span> and <span class="math">\(B\)</span> be subsets of <span class="math">\(X\)</span>. Show that <span class="math">\(f [A \cup B] = f[A] \cup f[B]\)</span>.</li>
<li>Let <span class="math">\(f: X \to Y\)</span> be any function, and let <span class="math">\(A\)</span> and <span class="math">\(B\)</span> be any subsets of <span class="math">\(X\)</span>. Show <span class="math">\(f[A] \setminus f[B] \subseteq f[A \setminus B]\)</span>.</li>
<li>Define notions of composition and inverse for binary relations that generalize the notions for functions.</li>
</ol>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="index.html">Logic and Proof</a></h1>








<!-- <h3>Navigation</h3> -->
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="introduction.html">1. Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="propositional_logic.html">2. Propositional Logic</a></li>
<li class="toctree-l1"><a class="reference internal" href="natural_deduction_for_propositional_logic.html">3. Natural Deduction for Propositional Logic</a></li>
<li class="toctree-l1"><a class="reference internal" href="propositional_logic_in_lean.html">4. Propositional Logic in Lean</a></li>
<li class="toctree-l1"><a class="reference internal" href="classical_reasoning.html">5. Classical Reasoning</a></li>
<li class="toctree-l1"><a class="reference internal" href="semantics_of_propositional_logic.html">6. Semantics of Propositional Logic</a></li>
<li class="toctree-l1"><a class="reference internal" href="first_order_logic.html">7. First Order Logic</a></li>
<li class="toctree-l1"><a class="reference internal" href="natural_deduction_for_first_order_logic.html">8. Natural Deduction for First Order Logic</a></li>
<li class="toctree-l1"><a class="reference internal" href="first_order_logic_in_lean.html">9. First Order Logic in Lean</a></li>
<li class="toctree-l1"><a class="reference internal" href="semantics_of_first_order_logic.html">10. Semantics of First Order Logic</a></li>
<li class="toctree-l1"><a class="reference internal" href="sets.html">11. Sets</a></li>
<li class="toctree-l1"><a class="reference internal" href="sets_in_lean.html">12. Sets in Lean</a></li>
<li class="toctree-l1"><a class="reference internal" href="relations.html">13. Relations</a></li>
<li class="toctree-l1"><a class="reference internal" href="relations_in_lean.html">14. Relations in Lean</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">15. Functions</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#the-function-concept">15.1. The Function Concept</a></li>
<li class="toctree-l2"><a class="reference internal" href="#injective-surjective-and-bijective-functions">15.2. Injective, Surjective, and Bijective Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="#functions-and-subsets-of-the-domain">15.3. Functions and Subsets of the Domain</a></li>
<li class="toctree-l2"><a class="reference internal" href="#functions-and-relations">15.4. Functions and Relations</a></li>
<li class="toctree-l2"><a class="reference internal" href="#exercises">15.5. Exercises</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="functions_in_lean.html">16. Functions in Lean</a></li>
<li class="toctree-l1"><a class="reference internal" href="the_natural_numbers_and_induction.html">17. The Natural Numbers and Induction</a></li>
<li class="toctree-l1"><a class="reference internal" href="the_natural_numbers_and_induction_in_lean.html">18. The Natural Numbers and Induction in Lean</a></li>
<li class="toctree-l1"><a class="reference internal" href="elementary_number_theory.html">19. Elementary Number Theory</a></li>
<li class="toctree-l1"><a class="reference internal" href="combinatorics.html">20. Combinatorics</a></li>
<li class="toctree-l1"><a class="reference internal" href="the_real_numbers.html">21. The Real Numbers</a></li>
<li class="toctree-l1"><a class="reference internal" href="the_infinite.html">22. The Infinite</a></li>
<li class="toctree-l1"><a class="reference internal" href="axiomatic_foundations.html">23. Axiomatic Foundations</a></li>
</ul>


<hr />
<ul>
    
    <li class="toctree-l1"><a href="logic_and_proof.pdf">PDF version</a></li>
    
    <li class="toctree-l1"><a href="https://leanprover.github.io/">Lean Home</a></li>
    
</ul>

<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2017, Jeremy Avigad, Robert Y. Lewis, and Floris van Doorn.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.6.3</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.10</a>
      
      |
      <a href="_sources/functions.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>